"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2298],{2512:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>h});var r=t(74848),n=t(28453),i=t(3514);const s={id:"learn-architecture",title:"Architecture",sidebar_label:"Architecture",description:"Key Components to Polkadot's Architecture.",keywords:["polkadot","components","architecture"],slug:"../learn-architecture"},o=void 0,c={id:"learn/learn-architecture",title:"Architecture",description:"Key Components to Polkadot's Architecture.",source:"@site/../docs/learn/learn-architecture.md",sourceDirName:"learn",slug:"/learn-architecture",permalink:"/docs/learn-architecture",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Filippo",lastUpdatedAt:1727943421e3,frontMatter:{id:"learn-architecture",title:"Architecture",sidebar_label:"Architecture",description:"Key Components to Polkadot's Architecture.",keywords:["polkadot","components","architecture"],slug:"../learn-architecture"},sidebar:"docs",previous:{title:"Claim Guides",permalink:"/docs/learn-guides-claims"},next:{title:"Consensus",permalink:"/docs/learn-consensus"}},l={},h=[{value:"Relay Chain",id:"relay-chain",level:2},{value:"Parachain Slots",id:"parachain-slots",level:2},{value:"Shared Security",id:"shared-security",level:3},{value:"Interoperability",id:"interoperability",level:2},{value:"XCM",id:"xcm",level:3},{value:"Bridges",id:"bridges",level:3},{value:"Validators",id:"validators",level:2},{value:"Nominators",id:"nominators",level:2},{value:"Collators",id:"collators",level:2}];function d(e){const a={a:"a",h1:"h1",h2:"h2",h3:"h3",p:"p",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.p,{children:"Polkadot is a heterogeneous multichain with shared security and interoperability."}),"\n",(0,r.jsx)(i.A,{}),"\n",(0,r.jsx)(a.h2,{id:"relay-chain",children:"Relay Chain"}),"\n",(0,r.jsx)(a.p,{children:"The relay chain is the central chain of Polkadot. All validators of are staked on the relay chain in\nDOT and validate for the relay chain. The relay chain is composed of a relatively small number of\ntransaction types that include ways to interact with the governance mechanism, and participating in\nNPoS. The relay chain has deliberately minimal functionality - for instance, smart contracts are not\nsupported. The main responsibility is to coordinate the system as a whole, including parachains.\nOther specific work is delegated to the parachains, which have different implementations and\nfeatures."}),"\n",(0,r.jsxs)(a.h2,{id:"parachain-slots",children:[(0,r.jsx)(a.a,{href:"/docs/learn-parachains",children:"Parachain"})," Slots"]}),"\n",(0,r.jsx)(a.p,{children:"The relay chain can support a number of execution cores, like cores on a computer's processor (a\nmodern laptop's processor may have eight cores, for example). Each one of these cores can run one\nprocess at a time. The relay chain allows these cores using two subscription models: parachains and\non-demand parachains. Parachains have a dedicated core for their chain and are like a process that\nruns constantly. On-demand parachains share (not simultaneously) cores amongst a group, and are thus\nmore like processes that need to be woken up and run less frequently (similarly to concurrency in\nmodern computers)."}),"\n",(0,r.jsx)(a.p,{children:"Most of the computation that happens across the network as a whole will be delegated to specific\nparachain implementations that handle various use cases. The relay chain places no constraints over\nwhat parachains can do besides that they must be able to generate a proof that can be validated by\nthe validators assigned to the parachain. This proof verifies the state transition of the parachain.\nSome parachains may be specific to a particular application, others may focus on specific features\nlike smart contracts, privacy, or scalability \u2014 still, others might be experimental\narchitectures that are not necessarily blockchain in nature."}),"\n",(0,r.jsxs)(a.p,{children:["The relay chain provides many ways to secure a core for a parachain for a particular length of time.\nOn-demand parachains share cores (not simultaneously) with other parachains. Both regular and\non-demand parachains have the same API and need to buy time on a core with DOT via\n",(0,r.jsx)(a.a,{href:"/docs/learn-agile-coretime",children:"coretime"}),". Parachains can switch between being on-demand and permanent."]}),"\n",(0,r.jsx)(a.h3,{id:"shared-security",children:(0,r.jsx)(a.a,{href:"/docs/learn-parachains",children:"Shared Security"})}),"\n",(0,r.jsx)(a.p,{children:"Parachains connected to the relay chain all share in the security of the relay chain. Polkadot has a\nshared state between the relay chain and all of the connected parachains. If the relay chain must\nrevert for any reason, then all of the parachains would also revert. This is to ensure that the\nvalidity of the entire system can persist and no individual part is corruptible."}),"\n",(0,r.jsx)(a.p,{children:"The shared state ensures that the trust assumptions when using parachains are only those of the\nrelay chain validator set and no other. Since the validator set on the relay chain is expected to be\nsecure with a large amount of stake put up to back it, parachains should benefit from this security."}),"\n",(0,r.jsx)(a.h2,{id:"interoperability",children:"Interoperability"}),"\n",(0,r.jsx)(a.h3,{id:"xcm",children:(0,r.jsx)(a.a,{href:"learn-xcm",children:"XCM"})}),"\n",(0,r.jsxs)(a.p,{children:["XCM, short for cross-consensus message, is a format and not a protocol. The format does not assume\nanything about the receiver or senders consensus mechanism, it only cares about the format in which\nthe messages must be structured in. The XCM format is how parachains will be able to communicate\nwith one another. Different from XCMP, which is short for cross-chain messaging protocol, XCM is\nwhat gets delivered, and XCMP is the delivery mechanism. The best way to learn more about XCM is by\nreading the ",(0,r.jsx)(a.a,{href:"https://github.com/paritytech/xcm-format",children:"specification"}),"."]}),"\n",(0,r.jsx)(a.h3,{id:"bridges",children:(0,r.jsx)(a.a,{href:"/docs/learn-bridges",children:"Bridges"})}),"\n",(0,r.jsxs)(a.p,{children:["A blockchain ",(0,r.jsx)(a.a,{href:"/docs/glossary#bridge",children:"bridge"})," is a connection that allows for arbitrary data\nto transfer from one network to another. These chains are interoperable through the bridge but can\nexist as standalone chains with different protocols, rules, and governance models. In Polkadot,\nbridges connect to the relay chain and are secured through the consensus mechanism, maintained by\n",(0,r.jsx)(a.a,{href:"#collators",children:"collators"}),"."]}),"\n",(0,r.jsx)(a.p,{children:"Polkadot uses bridges to bridge the future of Web 3.0, as bridges are fundamental to Polkadot's\ninteroperable architecture by acting as a secure and robust communication channel for chains in\nisolation."}),"\n",(0,r.jsx)(a.h1,{id:"main-actors",children:"Main Actors"}),"\n",(0,r.jsx)(a.h2,{id:"validators",children:"Validators"}),"\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.a,{href:"/docs/glossary#validator",children:"Validators"}),", if elected to the validator set, produce blocks on\nthe relay chain. They also accept proofs of valid state transition from collators and receive\nstaking rewards in return."]}),"\n",(0,r.jsxs)(a.p,{children:["Validators are required to keep enough parachain blocks available for later use in their local\nstorage. Those blocks are retrievable by peers who lack that information, so that they can reliably\nconfirm the issued validity statements about parachain blocks. The\n",(0,r.jsx)(a.a,{href:"https://spec.polkadot.network/#chapter-anv",children:"Availability & Validity"})," (AnV) protocol consists of\nmultiple steps for successfully upholding those responsibilities."]}),"\n",(0,r.jsx)(a.h2,{id:"nominators",children:"Nominators"}),"\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.a,{href:"/docs/glossary#nominator",children:"Nominators"})," bond their stake to particular validators in order to\nhelp them get into the active validator set and thus produce blocks for the chain. In return,\nnominators are generally rewarded with a portion of the staking rewards from that validator."]}),"\n",(0,r.jsx)(a.h2,{id:"collators",children:"Collators"}),"\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.a,{href:"/docs/glossary#collator",children:"Collators"})," are full nodes on both a parachain and the relay chain.\nThey collect parachain transactions and produce state transition proofs for the validators on the\nrelay chain. They can also send and receive messages from other parachains using XCMP."]}),"\n",(0,r.jsx)(a.p,{children:"Parachain blocks themselves are produced by collators, whereas the relay chain validators only\nverify their validity (and later, their availability)."})]})}function u(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},3514:(e,a,t)=>{t.d(a,{A:()=>b});t(96540);var r=t(34164),n=t(26972),i=t(28774),s=t(53465),o=t(16654),c=t(21312),l=t(51107);const h={cardContainer:"cardContainer_fWXF",cardTitle:"cardTitle_rnsV",cardDescription:"cardDescription_PWke"};var d=t(74848);function u(e){var a=e.href,t=e.children;return(0,d.jsx)(i.A,{href:a,className:(0,r.A)("card padding--lg",h.cardContainer),children:t})}function p(e){var a=e.href,t=e.icon,n=e.title,i=e.description;return(0,d.jsxs)(u,{href:a,children:[(0,d.jsxs)(l.A,{as:"h2",className:(0,r.A)("text--truncate",h.cardTitle),title:n,children:[t," ",n]}),i&&(0,d.jsx)("p",{className:(0,r.A)("text--truncate",h.cardDescription),title:i,children:i})]})}function m(e){var a,t,r=e.item,i=(0,n.Nr)(r),o=(t=(0,s.W)().selectMessage,function(e){return t(e,(0,c.T)({message:"1 item|{count} items",id:"theme.docs.DocCard.categoryDescription.plurals",description:"The default description for a category card in the generated index about how many items this category includes"},{count:e}))});return i?(0,d.jsx)(p,{href:i,icon:"\ud83d\uddc3\ufe0f",title:r.label,description:null!=(a=r.description)?a:o(r.items.length)}):null}function f(e){var a,t,r=e.item,i=(0,o.A)(r.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",s=(0,n.cC)(null!=(a=r.docId)?a:void 0);return(0,d.jsx)(p,{href:r.href,icon:i,title:r.label,description:null!=(t=r.description)?t:null==s?void 0:s.description})}function y(e){var a=e.item;switch(a.type){case"link":return(0,d.jsx)(f,{item:a});case"category":return(0,d.jsx)(m,{item:a});default:throw new Error("unknown item type "+JSON.stringify(a))}}function v(e){var a=e.className,t=(0,n.$S)();return(0,d.jsx)(b,{items:t.items,className:a})}function b(e){var a=e.items,t=e.className;if(!a)return(0,d.jsx)(v,Object.assign({},e));var i=(0,n.d1)(a);return(0,d.jsx)("section",{className:(0,r.A)("row",t),children:i.map((function(e,a){return(0,d.jsx)("article",{className:"col col--6 margin-bottom--lg",children:(0,d.jsx)(y,{item:e})},a)}))})}},53465:(e,a,t)=>{t.d(a,{W:()=>l});var r=t(96540),n=t(44586),i=["zero","one","two","few","many","other"];function s(e){return i.filter((function(a){return e.includes(a)}))}var o={locale:"en",pluralForms:s(["one","other"]),select:function(e){return 1===e?"one":"other"}};function c(){var e=(0,n.A)().i18n.currentLocale;return(0,r.useMemo)((function(){try{return a=e,t=new Intl.PluralRules(a),{locale:a,pluralForms:s(t.resolvedOptions().pluralCategories),select:function(e){return t.select(e)}}}catch(r){return console.error('Failed to use Intl.PluralRules for locale "'+e+'".\nDocusaurus will fallback to the default (English) implementation.\nError: '+r.message+"\n"),o}var a,t}),[e])}function l(){var e=c();return{selectMessage:function(a,t){return function(e,a,t){var r=e.split("|");if(1===r.length)return r[0];r.length>t.pluralForms.length&&console.error("For locale="+t.locale+", a maximum of "+t.pluralForms.length+" plural forms are expected ("+t.pluralForms.join(",")+"), but the message contains "+r.length+": "+e);var n=t.select(a),i=t.pluralForms.indexOf(n);return r[Math.min(i,r.length-1)]}(t,a,e)}}}},28453:(e,a,t)=>{t.d(a,{R:()=>s,x:()=>o});var r=t(96540);const n={},i=r.createContext(n);function s(e){const a=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(i.Provider,{value:a},e.children)}}}]);