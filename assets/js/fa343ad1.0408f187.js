"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2368],{37374:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var s=t(74848),i=t(28453);const a={id:"learn-xcm-docs-fundamentals-fees",title:"Weight and Fees",sidebar_label:"Weight and Fees",description:"Weight and Fees in XCM.",keywords:["xcm","cross-consensus messaging","weight","fees"],slug:"../fundamentals-fees"},o="Weight and fees",r={id:"learn/xcm/fundamentals/learn-xcm-docs-fundamentals-fees",title:"Weight and Fees",description:"Weight and Fees in XCM.",source:"@site/../docs/learn/xcm/fundamentals/weight_and_fees.md",sourceDirName:"learn/xcm/fundamentals",slug:"/learn/xcm/fundamentals-fees",permalink:"/docs/learn/xcm/fundamentals-fees",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"spazcoin",lastUpdatedAt:1715375475e3,frontMatter:{id:"learn-xcm-docs-fundamentals-fees",title:"Weight and Fees",sidebar_label:"Weight and Fees",description:"Weight and Fees in XCM.",keywords:["xcm","cross-consensus messaging","weight","fees"],slug:"../fundamentals-fees"},sidebar:"docs",previous:{title:"XCVM",permalink:"/docs/learn/xcm/fundamentals-xcvm"},next:{title:"A Journey through XCM",permalink:"/docs/learn/xcm/journey"}},c={},h=[{value:"Executor config",id:"executor-config",level:2},{value:"XCM pallet",id:"xcm-pallet",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"weight-and-fees",children:"Weight and fees"})}),"\n",(0,s.jsxs)(n.p,{children:["The resources available to a blockchain are limited, so it's important to manage how operations\non-chain use them. Not managing how resources are used can open an attack vector, known as DoS\n(Denial of Service), where an attacker floods the chain with operations in order to get it to stop\nproducing blocks. In order to manage how resources are used and to protect against DoS attacks, XCM\nuses a concept of ",(0,s.jsx)(n.em,{children:"weight"}),". This concept, which has the purpose of quantifying usage of blockchain\nresources, comes from the ",(0,s.jsx)(n.a,{href:"https://docs.substrate.io/build/tx-weights-fees/",children:"Substrate"})," world."]}),"\n",(0,s.jsx)(n.p,{children:"Weight is two-dimensional, it tracks both time (execution time) and space (state accesses). Weight\ndetermines how much fees need to be paid in order to perform some operation. The logic for turning\nit into fees is configurable."}),"\n",(0,s.jsxs)(n.p,{children:["Some systems have the concept of ",(0,s.jsx)(n.em,{children:"gas metering"}),", which is calculated during execution and only\nmeasures execution time. Weight, however, is static, defined beforehand, which makes XCM execution\nlighter by not including gas metering."]}),"\n",(0,s.jsxs)(n.p,{children:["The principle behind weight payment is to pay for what you use, so the two stages of XCM where fees\nare paid are ",(0,s.jsx)(n.em,{children:"sending"})," the message and actually ",(0,s.jsx)(n.em,{children:"executing"})," it. The fees for sending are paid on the\nlocal system, usually by the origin of the message, because we are using the message delivery\nmechanism maintained by the origin. Similarly, the execution fees are paid on the destination\nsystem, via the ",(0,s.jsx)(n.code,{children:"BuyExecution"})," instruction. In other words, XCMs are paid for via their own\ninstructions. We'll talk more about ",(0,s.jsx)(n.code,{children:"BuyExecution"})," in the\n",(0,s.jsx)(n.a,{href:"../journey-fees/index.html",children:"fee handling chapter"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["XCM is agnostic, which means it doesn't assume fees need to be paid. It's entirely possible to not\npay for the effects of an XCM on the destination system. Even in systems where fees have to be paid,\nspecial cases of free execution can be made. There are security measures systems can put in place\n(see ",(0,s.jsx)(n.a,{href:"/docs/learn/xcm/config-deep-dive#barrier",children:"barrier"}),") to not execute XCMs that do not pay for their\nfees."]}),"\n",(0,s.jsx)(n.h2,{id:"executor-config",children:"Executor config"}),"\n",(0,s.jsxs)(n.p,{children:["The executor has a ",(0,s.jsx)(n.code,{children:"Weigher"})," ",(0,s.jsx)(n.a,{href:"/docs/learn/xcm/config-deep-dive#weigher",children:"configuration item"})," that\nspecifies the weight of each instruction. It weighs the whole message by adding the weight of each\ninstruction. A simple way of weighing instructions is to assign them a base weight value to all of\nthem. This works, but it is not very accurate, as different instructions use more resources when\nbeing executed. A better approach is to benchmark each instruction to find out the actual weight\nused by each."]}),"\n",(0,s.jsxs)(n.p,{children:["Another configuration item, ",(0,s.jsx)(n.code,{children:"Trader"}),", converts the required weight units into fees, which are\nrepresented as ",(0,s.jsx)(n.code,{children:"MultiAsset"}),"s. There are two basic approaches: one is to just assign a value\n(measured in assets) to each unit of weight; the other is to reuse some existing transaction payment\nmethod for XCM weight. Custom configurations allow for things like NFT coupons that give you a\ncertain amount of weight for executing the XCM."]}),"\n",(0,s.jsx)(n.p,{children:"Naturally, this configuration items allow for any approach you can think of for weighing messages\nand charging execution fees."}),"\n",(0,s.jsx)(n.h2,{id:"xcm-pallet",children:"XCM pallet"}),"\n",(0,s.jsx)(n.p,{children:"FRAME pallets, like the XCM pallet, specify weights for each extrinsic they expose. That means that\nwhen interacting with pallets that deal with XCM, there will be an additional fee at the beginning\nfor calling the extrinsic locally."})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(96540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);