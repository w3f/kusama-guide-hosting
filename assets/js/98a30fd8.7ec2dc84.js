"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8866],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var s=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=s.createContext({}),u=function(e){var t=s.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return s.createElement(o.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},p=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=u(n),p=i,h=d["".concat(o,".").concat(p)]||d[p]||m[p]||a;return n?s.createElement(h,l(l({ref:t},c),{},{components:n})):s.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,l=new Array(a);l[0]=p;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r[d]="string"==typeof e?e:i,l[1]=r;for(var u=2;u<a;u++)l[u]=n[u];return s.createElement.apply(null,l)}return s.createElement.apply(null,n)}p.displayName="MDXCreateElement"},94062:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>u,toc:()=>d});var s=n(87462),i=n(63366),a=(n(67294),n(3905)),l=["components"],r={id:"learn-xcm-docs-fundamentals-multiasset",title:"MultiAsset",sidebar_label:"MultiAsset",description:"The MultiAsset Datatype.",keywords:["xcm","cross-consensus messaging","multilocation"],slug:"../fundamentals-multiasset"},o="MultiAsset",u={unversionedId:"learn/xcm/fundamentals/learn-xcm-docs-fundamentals-multiasset",id:"learn/xcm/fundamentals/learn-xcm-docs-fundamentals-multiasset",title:"MultiAsset",description:"The MultiAsset Datatype.",source:"@site/../docs/learn/xcm/fundamentals/multiasset.md",sourceDirName:"learn/xcm/fundamentals",slug:"/learn/xcm/fundamentals-multiasset",permalink:"/docs/learn/xcm/fundamentals-multiasset",draft:!1,tags:[],version:"current",lastUpdatedBy:"bader y",lastUpdatedAt:1694099593,formattedLastUpdatedAt:"Sep 7, 2023",frontMatter:{id:"learn-xcm-docs-fundamentals-multiasset",title:"MultiAsset",sidebar_label:"MultiAsset",description:"The MultiAsset Datatype.",keywords:["xcm","cross-consensus messaging","multilocation"],slug:"../fundamentals-multiasset"},sidebar:"docs",previous:{title:"Example",permalink:"/docs/learn/xcm/fundamentals/multilocation-example"},next:{title:"XCVM",permalink:"/docs/learn/xcm/fundamentals-xcvm"}},c={},d=[{value:"MultiAsset Breakdown",id:"multiasset-breakdown",level:2},{value:"How to use Multiple Assets Together?",id:"how-to-use-multiple-assets-together",level:2},{value:"MultiAssets",id:"multiassets",level:3},{value:"WildMultiAsset",id:"wildmultiasset",level:3},{value:"MultiAssetFilter",id:"multiassetfilter",level:3},{value:"Examples",id:"examples",level:2},{value:"MultiAsset",id:"multiasset-1",level:3},{value:"MultiAssetFilter",id:"multiassetfilter-1",level:3}],m={toc:d},p="wrapper";function h(e){var t=e.components,n=(0,i.Z)(e,l);return(0,a.kt)(p,(0,s.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"multiasset"},"MultiAsset"),(0,a.kt)("p",null,"When working with XCM, it is often needed to represent an asset of some sort. This is because\npractically all public blockchains in existence rely on some native digital asset to provide the\nbackbone for its internal economy and security mechanism. For example, the native asset for the\nPolkadot relay chain is DOT."),(0,a.kt)("p",null,"Some blockchains manage multiple assets, e.g. Ethereum\u2019s ERC-20 framework allows for many different\nassets to be managed on-chain. Some manage assets that are not fungible, such as Ethereum\u2019s\nCrypto-kitties \u2014 each kitty is a one-of-a-kind instance. It was an early example of such\nnon-fungible tokens or NFTs."),(0,a.kt)("p",null,"XCM is designed to be able to describe all such assets without breaking a sweat. For this purpose,\nthere is the ",(0,a.kt)("inlineCode",{parentName:"p"},"MultiAsset")," datatype, along with its related types ",(0,a.kt)("inlineCode",{parentName:"p"},"MultiAssets"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"WildMultiAsset"),",\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"MultiAssetFilter"),"."),(0,a.kt)("h2",{id:"multiasset-breakdown"},"MultiAsset Breakdown"),(0,a.kt)("p",null,"Let's take a look at the MultiAsset struct:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct MultiAsset {\n    pub id: AssetId,\n    pub fun: Fungibility,\n}\n")),(0,a.kt)("p",null,"So two fields define our asset: id and fun. These fields are indicative of how XCM approaches\nassets. Firstly, an overall asset identity must be provided. For fungible assets, this is simply a\nsymbol that identifies the asset. For NFTs this identifies the overall asset \u201cclass\u201d \u2014 different\nasset instances may be within this class."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"enum AssetId {\n   Concrete(MultiLocation),\n   Abstract([u8; 32]),\n}\n")),(0,a.kt)("p",null,"The asset identity is expressed in one of two ways; either Concrete or Abstract. Abstract identities\nallow assets to be specified by a 32-byte blob. This is convenient, but it relies on the receiver to\ninterpret the blob in the way that the sender expects, which will require a common definition\nbetween the sender and the receiver, and may not be simple to achieve. Concrete identities use a\n",(0,a.kt)("inlineCode",{parentName:"p"},"MultiLocation")," to identify an asset unambiguously. For native assets (such as DOT), the asset is\nidentified as the chain which mints the asset (the Polkadot Relay Chain in this case, which would be\nthe location ",(0,a.kt)("inlineCode",{parentName:"p"},"..")," from one of its parachains). Other assets (e.g. non-native assets or NFTs) can be\nidentified by a ",(0,a.kt)("inlineCode",{parentName:"p"},"GeneralIndex")," junction. Depending on the implementation of the encapsulating\nconsensus system, the exact location may differ (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"GeneralIndex(AssetID)")," or\n",(0,a.kt)("inlineCode",{parentName:"p"},"PalletInstance(PalletID)/GeneralIndex(AssetID)")," can both be valid asset identities)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"enum Fungibility {\n   // Fungible cannot be 0\n   Fungible(u128),\n   NonFungible(AssetInstance),\n}\n")),(0,a.kt)("p",null,"Secondly, they must be either fungible or non-fungible. If they\u2019re fungible, then there should be\nsome associated non-zero amount of assets specified. If they\u2019re not fungible, then instead of an\namount, there should be some indication of which\n",(0,a.kt)("a",{parentName:"p",href:"https://paritytech.github.io/polkadot/doc/xcm/v3/enum.AssetInstance.html"},"AssetInstance")," they are.\n(This is commonly expressed with an index, but XCM also allows arrays.)"),(0,a.kt)("h2",{id:"how-to-use-multiple-assets-together"},"How to use Multiple Assets Together?"),(0,a.kt)("p",null,"There are multiple ways to group Assets. In this section, we go over these methods."),(0,a.kt)("h3",{id:"multiassets"},"MultiAssets"),(0,a.kt)("p",null,"One way to group a set of ",(0,a.kt)("inlineCode",{parentName:"p"},"MultiAsset")," items is the\n",(0,a.kt)("a",{parentName:"p",href:"https://paritytech.github.io/polkadot/doc/xcm/v3/struct.MultiAssets.html"},"MultiAssets")," type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct MultiAssets(Vec<MultiAsset>);\n")),(0,a.kt)("p",null,"This structure must uphold some rules:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It may not contain duplicate ",(0,a.kt)("inlineCode",{parentName:"li"},"MultiAsset"),"s (",(0,a.kt)("inlineCode",{parentName:"li"},"Fungible")," assets are considered the same if their IDs\nmatch. However, ",(0,a.kt)("inlineCode",{parentName:"li"},"NonFungible")," assets are different if the ",(0,a.kt)("inlineCode",{parentName:"li"},"AssetInstance")," is different);"),(0,a.kt)("li",{parentName:"ul"},"All items must be ordered;"),(0,a.kt)("li",{parentName:"ul"},"The number of items should grow no larger than MAX_ITEMS_IN_MULTIASSETS (currently set to 20).")),(0,a.kt)("h3",{id:"wildmultiasset"},"WildMultiAsset"),(0,a.kt)("p",null,"Then we have WildMultiAsset; this is a wildcard that can be used to match against one or more\nMultiAsset items. All the WildMultiAsset wildcards can be used to select/filter assets in the\n",(0,a.kt)("a",{parentName:"p",href:"/docs/learn/xcm/overview-xcvm"},"Holding register"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum WildMultiAsset {\n    /// All assets in Holding.\n    All,\n    /// All assets in Holding of a given fungibility and ID.\n    AllOf { id: AssetId, fun: WildFungibility },\n    /// All assets in Holding, up to `u32` individual assets (different instances of non-fungibles\n    /// are separate assets).\n    AllCounted(#[codec(compact)] u32),\n    /// All assets in Holding of a given fungibility and ID up to `count` individual assets\n    /// (different instances of non-fungibles are separate assets).\n    AllOfCounted {\n        id: AssetId,\n        fun: WildFungibility,\n        #[codec(compact)]\n        count: u32,\n    },\n}\n")),(0,a.kt)("h3",{id:"multiassetfilter"},"MultiAssetFilter"),(0,a.kt)("p",null,"Finally, there is ",(0,a.kt)("inlineCode",{parentName:"p"},"MultiAssetFilter"),". This is used most often and is just a combination of\nMultiAssets and WildMultiAsset allowing either a wildcard or a list of definite (i.e. not wildcard)\nassets to be specified."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum MultiAssetFilter {\n    /// Specify the filter as being everything contained by the given `MultiAssets` inner.\n    Definite(MultiAssets),\n    /// Specify the filter as the given `WildMultiAsset` wildcard.\n    Wild(WildMultiAsset),\n}\n")),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("h3",{id:"multiasset-1"},"MultiAsset"),(0,a.kt)("p",null,"For more information about the MultiLocations used to define concrete assets, see\n",(0,a.kt)("a",{parentName:"p",href:"/docs/learn/xcm/fundamentals/multilocation-summary"},"MultiLocation")," and ",(0,a.kt)("a",{parentName:"p",href:"/docs/learn/xcm/fundamentals/multilocation-junctions"},"Junction"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// Location Relay Chain\n// 100 Native Asset (three ways)\nMultiAsset {id: Concrete(MultiLocation {parents: 0, interior: Here}), fun: Fungible(100u128)};\nMultiAsset {id: Here.into(), fun: 100.into()};\nlet _: MultiAsset = (Here, 100u128).into();\n\n// 100 Parachain's Native Asset\nlet _: MultiAsset = (X1(Parachain(1000)), 100u128).into();\n// 100 Fungible assets in Parachain 1000 with id 1234\nlet _: MultiAsset = (X2(Parachain(1000), GeneralIndex(1234)), 100u128).into();\n// Non Fungible asset with asset class 1234 containing only one nft instance in Parachain 1000\nlet _: MultiAsset = (X2(Parachain(1000), GeneralIndex(1234)), Undefined).into();\n// Non Fungible asset with asset class 1234 and AssetInstance 1 in Parachain 1000\nlet _: MultiAsset = (X2(Parachain(1000), GeneralIndex(1234)), Index(1)).into();\n")),(0,a.kt)("h3",{id:"multiassetfilter-1"},"MultiAssetFilter"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let a1: MultiAssets = MultiAssets::from(vec![MultiAsset {id: Here.into(), fun: 100u128.into()}]);\nlet b1: MultiAssets = (Here, 100u128).into();\nassert_eq!(a1, b1);\n\nlet a2: MultiAssetFilter = a1.into();\nlet b2 = MultiAssetFilter::Definite((Here, 100u128).into());\nassert_eq!(a2, b2);\n\nlet a3 = MultiAssetFilter::Wild(WildMultiAsset::All);\nlet b3: MultiAssetFilter = All.into();\nassert_eq!(a3, b3);\n")))}h.isMDXComponent=!0}}]);