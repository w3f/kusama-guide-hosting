"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1914],{70137:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>l});var r=s(74848),i=s(28453);const t={id:"learn-snowbridge",title:"Snowbridge",sidebar_label:"Snowbridge",description:"Overview of Snowbridge by Snowfork",keywords:["Bridge","XCM","Bridge Hub","Snowbridge","Snowfork"],slug:"../learn-snowbridge"},o=void 0,a={id:"learn/learn-snowbridge",title:"Snowbridge",description:"Overview of Snowbridge by Snowfork",source:"@site/../docs/learn/learn-snowbridge.md",sourceDirName:"learn",slug:"/learn-snowbridge",permalink:"/docs/learn-snowbridge",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Filippo",lastUpdatedAt:1725460864e3,frontMatter:{id:"learn-snowbridge",title:"Snowbridge",sidebar_label:"Snowbridge",description:"Overview of Snowbridge by Snowfork",keywords:["Bridge","XCM","Bridge Hub","Snowbridge","Snowfork"],slug:"../learn-snowbridge"}},d={},l=[{value:"Random-sampling BEEFY",id:"random-sampling-beefy",level:2},{value:"Snowbridge Crypto-economic Security",id:"snowbridge-crypto-economic-security",level:2},{value:"Snowbridge Assumptions",id:"snowbridge-assumptions",level:3},{value:"Resources",id:"resources",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{title:"Using Snowbridge",type:"info",children:(0,r.jsxs)(n.p,{children:["Snowbridge can be accessed through ",(0,r.jsx)(n.a,{href:"https://app.snowbridge.network/",children:"the web app"}),", where you may\ntrack ",(0,r.jsx)(n.a,{href:"https://app.snowbridge.network/status",children:"processing times of transactions"}),",\n",(0,r.jsx)(n.a,{href:"https://app.snowbridge.network/history",children:"recent transfers"}),", and other information about the bridge's\noverall status."]})}),"\n",(0,r.jsxs)(n.p,{children:["Snowbridge by ",(0,r.jsx)(n.a,{href:"https://snowfork.com/",children:"Snowfork"})," is a general-purpose, trustless bridge between\nPolkadot and Ethereum. It utilizes the\n",(0,r.jsx)(n.a,{href:"/docs/learn-system-chains#bridge-hub",children:"Bridge Hub system parachain"})," to establish a connection to its\nrelayers, allowing for permissionless and trustless messaging between Ethereum and Polkadot."]}),"\n",(0,r.jsxs)(n.p,{children:["With Snowbridge, a sender can (but does not need to) run a\n",(0,r.jsx)(n.a,{href:"https://docs.snowbridge.network/architecture/relayers",children:"relayer"})," to ensure that their cross-chain\ntransaction is successful. A sender is a user using relayers provided by others."]}),"\n",(0,r.jsxs)(n.p,{children:["Snowbridge currently supports\n",(0,r.jsx)(n.a,{href:"https://docs.snowbridge.network/applications/token-transfers",children:"two-way token transfers"})," between\nEthereum and Polkadot parachain."]}),"\n",(0,r.jsx)(n.h2,{id:"random-sampling-beefy",children:"Random-sampling BEEFY"}),"\n",(0,r.jsxs)(n.p,{children:["A trustless bridge always has a ",(0,r.jsx)(n.strong,{children:"prover"})," (needs to compute the proof), a ",(0,r.jsx)(n.strong,{children:"verifier"})," (asks the\nprover to compute the proof and verifies it), and relayers to relay messages. Snowbridge prover uses\n",(0,r.jsx)(n.a,{href:"/docs/learn-consensus#bridging-beefy",children:"BEEFY"}),", a novel bridge protocol drastically reducing\noperational costs without compromising security."]}),"\n",(0,r.jsxs)(n.p,{children:["Even with simplifications ushered in by BEEFY, a smart contract updating Polkadot's state on\nEthereum has to perform 201 signature checks for every update since there are ~300 validators on\nPolkadot. This remains expensive (gas costs), especially as the validator set grows. The solution is\nrandom-sampling BEEFY that leverages\n",(0,r.jsx)(n.a,{href:"https://eth2book.info/capella/part2/building_blocks/randomness/",children:"the RANDAO randomness beacon"})," as\nfollows:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Commit:"})," Relayer submits a state commitment of a recently finalized block on Polkadot and\nclaims to have a super-majority of validator\u2019s signatures to the light client deployed on\nEthereum. It also provides one validator signature backing the commitment, which can be slashed if\nneeded."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Challenge:"})," Light client queries on-chain randomness (RANDAO) to subsample ",(0,r.jsx)(n.code,{children:"m"})," (~25) signatures\nfrom the list Relayer\u2019s claimed list."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Response:"})," Relayer responds by sharing exactly those ",(0,r.jsx)(n.code,{children:"m"})," signatures that were randomly sampled\nwhich the light client then verifies. If everything checks out, the finalized block is accepted."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The number of signature checks needed is significantly reduced and independent of the validator set\nsize, making the protocol more efficient. The number of subsampled signatures, ",(0,r.jsx)(n.code,{children:"m,"})," is the parameter\nthat trades off security and efficiency (i.e., ",(0,r.jsx)(n.strong,{children:"security parameter"}),"). The value of this parameter\nis derived using crypto-economic arguments."]}),"\n",(0,r.jsx)(n.h2,{id:"snowbridge-crypto-economic-security",children:"Snowbridge Crypto-economic Security"}),"\n",(0,r.jsxs)(n.p,{children:["If up to a third of the validators are malicious, the chance that all ",(0,r.jsx)(n.code,{children:"m"})," signatures subsampled are\nfrom these bad actors is ",(0,r.jsx)(n.code,{children:"(1/2)^m"})," (exponentially low). Any validator who supports a malicious\ncommitment ",(0,r.jsx)(n.a,{href:"/docs/learn-offenses",children:"faces severe penalties"}),". The expected value of an attack ",(0,r.jsx)(n.code,{children:"E(A)"})," is:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"E(A) = p * V + (1 - p)*(-S)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Where ",(0,r.jsx)(n.code,{children:"V"})," is the value of attack (bounded by market capitalization), ",(0,r.jsx)(n.code,{children:"S"})," is the validator slashable\nstake, and ",(0,r.jsx)(n.code,{children:"p"})," is the probability of a successful attack."]}),"\n",(0,r.jsx)(n.h3,{id:"snowbridge-assumptions",children:"Snowbridge Assumptions"}),"\n",(0,r.jsx)(n.p,{children:"Snowbridge relies on two major assumptions:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The crypto-economic assumption that an adversary is rational, i.e., an attack is launched only if\nthe expected value of an attack is positive. Hence, we derive our security parameter ",(0,r.jsx)(n.code,{children:"m"})," by\nensuring the expected value of an attack is negative, i.e., ",(0,r.jsx)(n.code,{children:"E(A) < 0"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"RANDAO unpredictability. The Web3 Foundation research team performed a thorough analysis of RANDAO\nbias and extended the state-of-the-art in analysing the last-revealer attack on RANDAO. Assuming\n1/3rd of Ethereum validators are malicious, the effect of such bias is mitigated by proportionally\nincreasing the security parameter."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Medium article\n",(0,r.jsx)(n.a,{href:"https://medium.com/@bhargav_22496/18a43a2cba9b",children:'"Random Sampling BEEFY: Pillaring the trust-less Snowbridge"'}),"\nby Bhargav Bhatt at Web3 Foundation"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/Snowfork/snowbridge",children:"Snowbridge GitHub repository"})}),"\n",(0,r.jsx)(n.li,{children:"Web3 Foundation Research Repository"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(96540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);