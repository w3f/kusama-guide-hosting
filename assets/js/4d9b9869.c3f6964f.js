"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9550],{75024:(e,a,i)=>{i.r(a),i.d(a,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>h});var n=i(74848),t=i(28453);const o={id:"learn-parachains-protocol",title:"Parachains' Protocol Overview",sidebar_label:"Protocol Overview",description:"Actors and Protocols involved in Polkadot and its Parachains' Block Finality.",keywords:["parachains","application-specific","sharding","protocol","validator","collator","nominator","AnV","availability","validity"],slug:"../learn-parachains-protocol"},s=void 0,r={id:"learn/learn-parachains-protocol",title:"Parachains' Protocol Overview",description:"Actors and Protocols involved in Polkadot and its Parachains' Block Finality.",source:"@site/../docs/learn/learn-parachains-protocol.md",sourceDirName:"learn",slug:"/learn-parachains-protocol",permalink:"/docs/learn-parachains-protocol",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Filippo",lastUpdatedAt:1726760224e3,frontMatter:{id:"learn-parachains-protocol",title:"Parachains' Protocol Overview",sidebar_label:"Protocol Overview",description:"Actors and Protocols involved in Polkadot and its Parachains' Block Finality.",keywords:["parachains","application-specific","sharding","protocol","validator","collator","nominator","AnV","availability","validity"],slug:"../learn-parachains-protocol"},sidebar:"docs",previous:{title:"Introduction to Parachains",permalink:"/docs/learn-parachains"},next:{title:"System Parachains",permalink:"/docs/learn-system-chains"}},l={},h=[{value:"Main Actors",id:"main-actors",level:2},{value:"Validators",id:"validators",level:3},{value:"Collators",id:"collators",level:3},{value:"Fishermen: Deprecated",id:"fishermen-deprecated",level:3},{value:"Protocols&#39; Summary",id:"protocols-summary",level:2},{value:"Parachain Protocol",id:"parachain-protocol",level:3},{value:"Availability and Validity (AnV) Protocol",id:"availability-and-validity-anv-protocol",level:3},{value:"Inclusion Pipeline",id:"inclusion-pipeline",level:2},{value:"Overview",id:"overview",level:3},{value:"Parachain Phase",id:"parachain-phase",level:3},{value:"Relay Chain Submission Phase",id:"relay-chain-submission-phase",level:3},{value:"Availability and Unavailability Phase",id:"availability-and-unavailability-phase",level:3},{value:"Failure to Inclusion",id:"failure-to-inclusion",level:3},{value:"Approval Process",id:"approval-process",level:2},{value:"Overview",id:"overview-1",level:3},{value:"Assignments &amp; Secondary Checks",id:"assignments--secondary-checks",level:3},{value:"Chain Selection",id:"chain-selection",level:3},{value:"Candidate Receipts",id:"candidate-receipts",level:2},{value:"Erasure Codes",id:"erasure-codes",level:2},{value:"Disputes",id:"disputes",level:2},{value:"Network Asynchrony",id:"network-asynchrony",level:2},{value:"Further Resources",id:"further-resources",level:2}];function c(e){const a={a:"a",admonition:"admonition",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.admonition,{type:"info",children:(0,n.jsxs)(a.p,{children:["This page is a summary of the\n",(0,n.jsxs)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-overview.html",children:["Protocol Overview chapter in ",(0,n.jsx)(a.strong,{children:"The Polkadot Parachain Host Implementer's Guide"})]}),"\nand the\n",(0,n.jsxs)(a.a,{href:"https://spec.polkadot.network/chapter-anv",children:["Availability and Validity (AnV) chapter in ",(0,n.jsx)(a.strong,{children:"The Polkadot Protocol Specification"})]}),"."]})}),"\n",(0,n.jsx)(a.p,{children:"The Parachains' Protocol aims to carry a parachain's block from authoring to inclusion through a\nprocess that can be carried out repeatedly and in parallel for each parachain connected to the Relay\nChain. The protocol allows the network to be efficiently sharded among parachains while maintaining\nstrong security guarantees. The Availability and Validity (AnV) Protocol describes the Parachain\nProtocol from the perspective of availability and validity. on)."}),"\n",(0,n.jsx)(a.h2,{id:"main-actors",children:"Main Actors"}),"\n",(0,n.jsx)(a.h3,{id:"validators",children:(0,n.jsx)(a.a,{href:"/docs/learn-validator",children:"Validators"})}),"\n",(0,n.jsxs)(a.p,{children:["They are responsible for validating the proposed parachain's blocks by checking the\n",(0,n.jsx)(a.strong,{children:"Proof-of-Validity"}),' (PoV) of the blocks and ensuring the PoV remains available for a designated\nperiod. They have "skin in the game", meaning they have funds bonded on-chain that can be partially\nor fully confiscated by the network in case of misbehavior.']}),"\n",(0,n.jsx)(a.h3,{id:"collators",children:(0,n.jsx)(a.a,{href:"/docs/learn-collator",children:"Collators"})}),"\n",(0,n.jsx)(a.p,{children:"They create the PoV that validators know how to check. Creating PoV requires familiarity with\ntransaction format and block authoring rules of a specific parachain, as well as having access to\nits full state."}),"\n",(0,n.jsx)(a.h3,{id:"fishermen-deprecated",children:"Fishermen: Deprecated"}),"\n",(0,n.jsxs)(a.p,{children:["Fishermen are not planned for formal implementation, despite previous proposals in the\n",(0,n.jsx)(a.a,{href:"/docs/learn-parachains-protocol#availability-and-validity-anv-protocol",children:"AnV protocol"}),"."]}),"\n",(0,n.jsx)(a.p,{children:"The idea behind Fishermen is that they are full nodes of parachains, like collators, but perform a\ndifferent role in relation to the network. Instead of packaging the state transitions and producing\nthe next parachain blocks as collators do, fishermen will watch this process and ensure no invalid\nstate transitions are included."}),"\n",(0,n.jsxs)(a.p,{children:["To address the motivation behind the Fishermen design consideration, the current\n",(0,n.jsx)(a.a,{href:"#assignments--secondary-checks",children:"secondary backing checkers"})," perform a similar role in relation to\nthe network. From a security standpoint, security is based on having at least one honest validator\neither among parachain validators or secondary checker (more about this later on)."]}),"\n",(0,n.jsx)(a.h2,{id:"protocols-summary",children:"Protocols' Summary"}),"\n",(0,n.jsx)(a.h3,{id:"parachain-protocol",children:"Parachain Protocol"}),"\n",(0,n.jsx)(a.p,{children:"The parachain protocol is divided into two main phases:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.a,{href:"#inclusion-pipeline",children:(0,n.jsx)(a.strong,{children:"Inclusion Pipeline"})}),": Collators send parachain blocks (parablocks) with\nPoV to Validators. Validators verify if the parablocks follow the state transition rules of the\nparachain and sign statements that can have a positive or negative outcome. With enough positive\nstatements, the block is ",(0,n.jsx)(a.strong,{children:"backed"})," and ",(0,n.jsx)(a.strong,{children:"included"})," in the relay chain, but is still pending\napproval."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.a,{href:"#approval-process",children:(0,n.jsx)(a.strong,{children:"Approval Process"})}),": Validators perform additional checks that, if positive,\nallow the parablock to be ",(0,n.jsx)(a.strong,{children:"approved"}),"."]}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"The figure below shows a representation of a parachain with collators and validators. The figure\nalso shows the journey of a parachain block (white square) through the Inclusion Pipeline and the\nApproval Process."}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"parachain-protocol-summary",src:i(67937).A+"",width:"1920",height:"800"})}),"\n",(0,n.jsx)(a.h3,{id:"availability-and-validity-anv-protocol",children:"Availability and Validity (AnV) Protocol"}),"\n",(0,n.jsxs)(a.p,{children:["The Availability and Validity (AnV) Protocol is a way of looking at the Parachain Protocol from\nanother perspective, emphasizing the importance of a parablock being available and valid before\nbeing included in the finalized relay chain. It is divided into five different phases, three within\nthe ",(0,n.jsx)(a.a,{href:"#inclusion-pipeline",children:"Inclusion Pipeline"})," and two within the\n",(0,n.jsx)(a.a,{href:"#approval-process",children:"Approval Process"}),":"]}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.strong,{children:"Inclusion Pipeline"}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsx)(a.li,{children:(0,n.jsx)(a.a,{href:"#parachain-phase",children:"Parachain phase"})}),"\n",(0,n.jsx)(a.li,{children:(0,n.jsx)(a.a,{href:"#relay-chain-submission-phase",children:"Relay Chain submission phase"})}),"\n",(0,n.jsx)(a.li,{children:(0,n.jsx)(a.a,{href:"#availability-and-unavailability-phase",children:"Availability and unavailability phase"})}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.strong,{children:"Approval Process"}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsx)(a.li,{children:(0,n.jsx)(a.a,{href:"#assignments--secondary-checks",children:"Assignments and secondary (validity) checks"})}),"\n",(0,n.jsx)(a.li,{children:(0,n.jsx)(a.a,{href:"#chain-selection",children:"Chain Selection"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"In the Inclusion Pipeline, a parablock is made available (or unavailable), while in the Approval\nProcess a parablock is checked if it is valid or not."}),"\n",(0,n.jsx)(a.h2,{id:"inclusion-pipeline",children:"Inclusion Pipeline"}),"\n",(0,n.jsx)(a.h3,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(a.p,{children:"The inclusion pipeline is the path of a parachain block (or parablock) from its creation to its\ninclusion into the non-finalized relay chain (i.e. in a fork of the relay chain)."}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"parachain-inclusion-pipeline",src:i(45379).A+"",width:"1920",height:"800"})}),"\n",(0,n.jsx)(a.p,{children:"The figure above shows the path of a candidate block through the Inclusion pipeline. The block\nchanges its status through this path as follows:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"Candidate: A block with its PoV is put forward by a collator to a para-validator (in this case\nV1). The candidate block is shown as a white square with one white tick mark at the side (PoV from\nthe collator). Note the candidate is not valid yet and can still fail to be included in the Relay\nChain."}),"\n",(0,n.jsx)(a.li,{children:"Seconded: The block is put forward by the para-validator V1 to other para-validators (in this case\nV2 and V3). The seconded block is shown as a white square with a white tick mark and a yellow tick\nmark on top of it. The yellow mark show the PoV from para-validator V1."}),"\n",(0,n.jsx)(a.li,{children:"Backable: The block validity is attested by a majority of the para-validators. The backable block\nis shown as white square with a white tick mark and three yellow tick marks on top of it. The\nyellow marks show the PoV from the para-validators, while the white mark the PoV from the\ncollator."}),"\n",(0,n.jsx)(a.li,{children:'Backed: The block is backed and noted in a fork on the relay chain by a relay chain block author\n(in this case V4). The backed block is shown as a square with white background and yellow border\nenclosing a "B". The backed block can still fail to be included in the relay chain. Note that for\nsimplicity here the backed parachain block is represented within the relay chain block, but in\nreality a relay chain block does not contain the parablocks themselves (more about this later).'}),"\n",(0,n.jsx)(a.li,{children:"Pending availability: The block is backed but not considered available yet."}),"\n",(0,n.jsx)(a.li,{children:'Included: The block is backed and considered available (we have a parablock). Included parablocks\nare shown as square with white background and yellow border enclosing an "I".'}),"\n"]}),"\n",(0,n.jsx)(a.admonition,{title:"Asynchronous Backing",type:"info",children:(0,n.jsxs)(a.p,{children:["Parablocks' backing and inclusion take 12 seconds to be recorded on the relay chain, i.e. backing\nhappens in one relay chain block (6 seconds) and inclusion in another relay chain block (additional\n6 seconds, see Figure above). With ",(0,n.jsx)(a.a,{href:"/docs/learn-async-backing",children:(0,n.jsx)(a.strong,{children:"asynchronous backing"})}),", backing and\ninclusion can be recorded in just one relay chain block."]})}),"\n",(0,n.jsx)(a.h3,{id:"parachain-phase",children:"Parachain Phase"}),"\n",(0,n.jsxs)(a.p,{children:["In the parachain phase, some validators are assigned to parachains by the ",(0,n.jsx)(a.strong,{children:"Validator Assignment\nRoutine"})," (these validators are called para-validators). Para-validators establish a connection with\ncollators, which propose candidate blocks together with Proof-of-Validity (PoV) to para-validators\nvia the ",(0,n.jsx)(a.strong,{children:"Collator Distribution Subsystem"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["Para-validators participate in the ",(0,n.jsx)(a.strong,{children:"Candidate Backing Subsystem"}),". A para-validator needs to check\nif the candidate block follows the\n",(0,n.jsx)(a.a,{href:"/docs/learn-parachains#state-transitions",children:"state transition"})," rules of the parachain. Because\nstates are stored within Merkle trees, a para-validator can verify state transitions without having\naccess to the entire state, but it needs:"]}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"The block candidate (list of state transitions)"}),"\n",(0,n.jsx)(a.li,{children:"The values in the parachain's database that the block modifies"}),"\n",(0,n.jsx)(a.li,{children:"The hashes of the unaffected points in the Merkle tree"}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"This set of information is the proof-of-validity (PoV)."}),"\n",(0,n.jsxs)(a.p,{children:["Once a para-validator has the PoV, it gossips this information to the other para-validators, who\ncheck the candidate block against the PoV. Candidates that gather more than half of signed validity\nstatements are considered ",(0,n.jsx)(a.strong,{children:"backable"})," (i.e. they ",(0,n.jsx)(a.em,{children:"seem"})," to represent a valid state transition), and\ntheir backing is the set of signed statements. The para-validators can then start to construct the\n",(0,n.jsx)(a.a,{href:"#candidate-receipts",children:(0,n.jsx)(a.strong,{children:"candidate receipt"})})," (this is what goes into the relay chain block) and an\n",(0,n.jsx)(a.a,{href:"#erasure-codes",children:(0,n.jsx)(a.strong,{children:"erasure coding"})})," (this is what will make the parablock available, more on this\nlater on) that will be sent to all validators in the network."]}),"\n",(0,n.jsx)(a.admonition,{title:"Polkadot guarantees valid state transitions, not valid states",type:"info",children:(0,n.jsx)(a.p,{children:"Validators do not inspect every value in a parachain's state, only those that are modified. This\ninsures that the modification is valid."})}),"\n",(0,n.jsxs)(a.p,{children:["Previously, we said that backable blocks ",(0,n.jsx)(a.em,{children:"seem"})," to represent valid state transitions because\npara-validators are a small subset of all validators. Thus, it is possible to have the majority of\nthem dishonest. Later on, we will see that more validators with come in to help to make sure the\nparablock is fully valid."]}),"\n",(0,n.jsx)(a.h3,{id:"relay-chain-submission-phase",children:"Relay Chain Submission Phase"}),"\n",(0,n.jsxs)(a.p,{children:["The ",(0,n.jsx)(a.a,{href:"#candidate-receipts",children:"receipt"})," of the backable parablock is added to the relay chain transaction\nqueue together with other receipts from other parachains. Receipts are gossiped around, and when a\nrelay chain block author wins ",(0,n.jsx)(a.a,{href:"/docs/learn-consensus#block-production-babe",children:"BABE"})," slot leadership, it\nwill select a candidate receipt to include in a block on a fork of the relay chain."]}),"\n",(0,n.jsxs)(a.p,{children:["A block author can note up to 1 backable candidate for each parachain to be included in the Relay\nChain block alongside its backing. Once included in a fork of the relay chain the candidate is\nconsidered ",(0,n.jsx)(a.strong,{children:"backed"})," in that fork. The candidate is considered to be in ",(0,n.jsx)(a.strong,{children:'"pending availability"'}),"\nstatus, and it can only be considered a part of the parachain once proven available. Remember, at\nthis stage validators of the relay chain already received the\n",(0,n.jsx)(a.a,{href:"#erasure-codes",children:"erasure coding information"})," of that specific parablock."]}),"\n",(0,n.jsx)(a.h3,{id:"availability-and-unavailability-phase",children:"Availability and Unavailability Phase"}),"\n",(0,n.jsxs)(a.p,{children:["During the availability and unavailability phases, the validators will participate to ",(0,n.jsx)(a.strong,{children:"Availability\nDistribution Subsystem"})," to ensure availability of the candidate. They gossip the\n",(0,n.jsx)(a.a,{href:"#erasure-codes",children:"erasure coded"})," pieces among the network. At least 1/3 + 1 validators must report\nthat they possess their piece of the code word. Once this threshold of validators has been reached,\nthe network can consider the candidate block available. The block is graduated to being a full\nparachain block, and its header will be included in that fork of the relay chain. The information\nabout the candidate availability is noted in the subsequent relay chain blocks of that fork."]}),"\n",(0,n.jsxs)(a.p,{children:["The availability check by the block author ensures that the relay chain will only include blocks for\nwhich the validators distributed their erasure-coded chunks, but it does not guarantee their\nvalidity. Because the number of para-validators on each parachain is so low, collusion is a\nreasonable concern. By separating block production\n(",(0,n.jsx)(a.a,{href:"/docs/learn-consensus#block-production-babe",children:"BABE"}),") from finality\n(",(0,n.jsx)(a.a,{href:"./learn-consensus.md/#finality-gadget-grandpa",children:"GRANDPA"}),"), validators can perform extra validity\nchecks after a block is produced but before it is finalized."]}),"\n",(0,n.jsxs)(a.p,{children:['Thus, once the parablock is considered available and part of the parachain, it is still "pending\napproval". The Inclusion Pipeline must conclude for a specific parachain before a new block can be\naccepted on that parachain. After inclusion, the ',(0,n.jsx)(a.a,{href:"#approval-process",children:"Approval Process"})," starts and it\nmakes sure the block is valid, and it can run for many parachain blocks at once."]}),"\n",(0,n.jsx)(a.admonition,{title:"Data Availability - Erasure Codes of Parachain Blocks and PoVs",type:"info",children:(0,n.jsxs)(a.p,{children:["The erasure code chunks necessary for reconstructing parachain blocks and their respective\nProofs-of-Validity (PoV) are stored on the relay chain validator\u2019s hardware (disk) and made\navailable to the relay chain network for up to 24 hours. It is important to note that this data is\nneither stored within the relay chain blocks nor in the chain state. Only the root of those chunks\nis embedded within the ",(0,n.jsx)(a.a,{href:"#candidate-receipts",children:"candidate receipt"})," and is stored in the relay chain\nblocks."]})}),"\n",(0,n.jsx)(a.h3,{id:"failure-to-inclusion",children:"Failure to Inclusion"}),"\n",(0,n.jsx)(a.p,{children:"The candidate can fail to be included in the parachain in any of the following ways:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"The collator cannot propagate the block to any of the assigned validators."}),"\n",(0,n.jsx)(a.li,{children:"The candidate is not backed by validators participating in the Candidate Backing subsystem."}),"\n",(0,n.jsx)(a.li,{children:"A relay chain block author does not select the candidate."}),"\n",(0,n.jsx)(a.li,{children:"The candidate's PoV is not considered available within a timeout, and the block is discarded from\nthe relay chain."}),"\n"]}),"\n",(0,n.jsx)(a.h2,{id:"approval-process",children:"Approval Process"}),"\n",(0,n.jsx)(a.h3,{id:"overview-1",children:"Overview"}),"\n",(0,n.jsxs)(a.p,{children:['Once the parablock is considered available and part of the parachain, it is still "pending\napproval". At this stage, the parablock is tentatively included in the parachain, although more\nconfirmation is necessary. The validators assigned to the parachain (i.e. the parachain validators)\nare sampled from a validator set assumed to be 1/3 dishonest in the worst-case scenario. In this\ncase, it is likely that the majority of the random para-validators sampled for a specific parachain\nare dishonest and can back a candidate wrongly. To address this, the ',(0,n.jsx)(a.strong,{children:"Approval Process"})," allows\ndetecting misbehavior after the fact without allocating more para-validators, which would ultimately\nreduce the system's throughput. As a parablock can accept children blocks after being considered\navailable, failure to pass the approval process will invalidate the parablock and its descendants\n(children blocks). Only the validators who backed the block in question will be\n",(0,n.jsx)(a.a,{href:"/docs/learn-offenses",children:"slashed"}),", not those who backed the descendants."]}),"\n",(0,n.jsx)(a.p,{children:"The approval pipeline can be divided into the following steps:"}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsxs)(a.li,{children:["Parablocks included by the Inclusion Pipeline are pending approval for a time window known as the\n",(0,n.jsx)(a.strong,{children:"secondary checking window"}),"."]}),"\n",(0,n.jsxs)(a.li,{children:["During the secondary checking window, validators (secondary checkers) randomly self-select based\non a ",(0,n.jsx)(a.a,{href:"./learn-cryptography#vrf",children:"VRF"})," lottery to perform secondary checks on each of the\nparablock."]}),"\n",(0,n.jsx)(a.li,{children:"Secondary checkers acquire the parablock with PoV (erasure codings are necessary to reconstruct\nPoV) and re-run the validation function."}),"\n",(0,n.jsx)(a.li,{children:"Secondary checkers gossip about the results of their checks. Contradictory results lead to an\nescalation in which all validators must check the block. The validators on the losing side will\nbe slashed."}),"\n",(0,n.jsx)(a.li,{children:"At the end of the process the parablock is either approved or rejected."}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["The figure below shows the path of a parachain block when it exits the Inclusion Pipeline, and\nenters the Approval Process. The parablock becomes accepted when it is backed, available and\n",(0,n.jsx)(a.strong,{children:"undisputed"}),'. The parablock is checked a second time by a subset of validators (V5, V6 and V7),\nand if there are no contradictory results the block is approved and gossiped to other relay chain\nvalidators. Note the parablock after secondary checks is shown as a square with a white background a\nyellow border enclosing an "I" (stands for ',(0,n.jsx)(a.em,{children:"included"}),"), and three white ticks (one for each\nsecondary check). Approved para-blocks are shown as yellow squares."]}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"parachain-approval-process",src:i(60187).A+"",width:"1920",height:"800"})}),"\n",(0,n.jsx)(a.h3,{id:"assignments--secondary-checks",children:"Assignments & Secondary Checks"}),"\n",(0,n.jsxs)(a.p,{children:["Having a bad parablock on a fork of the relay chain is not catastrophic as long as the block is not\napproved and finalized by the finality gadget\n",(0,n.jsx)(a.a,{href:"./learn-consensus.md/#finality-gadget-grandpa",children:"GRANDPA"}),". If the block is not finalized, the fork on\nthe chain containing that block can be ignored in favor of another fork containing good blocks.\nDealing with a bad parablock includes the following stages:"]}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"Detection: the bad block must be detected by honest validators."}),"\n",(0,n.jsxs)(a.li,{children:["Escalation: the honest validators must start a ",(0,n.jsx)(a.a,{href:"#disputes",children:"dispute"}),"."]}),"\n",(0,n.jsxs)(a.li,{children:["Consequences: the backer for that parablock is ",(0,n.jsx)(a.a,{href:"/docs/learn-offenses",children:"slashed"}),"."]}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"The result of the dispute must be transplantable to all other forks so that malicious validators are\nslashed in all possible histories and so that honest validators will ignore any forks containing\nthat parablock."}),"\n",(0,n.jsx)(a.admonition,{title:"Parablocks vs. relay chain Blocks",type:"info",children:(0,n.jsx)(a.p,{children:"It is important to understand that a relay chain block does not contain parablocks, but\npara-headers. Parachain blocks are within the parachain. Thus, it makes more sense to think of\nrelay-chain blocks as having been approved instead of parablocks that have been approved. A\nrelay-chain block containing information about approved parablocks can be considered approved as\nlong as its parent relay-chain block is also approved. Thus, the validity of a relay-chain block\ndepends on the validity of its ancestry."})}),"\n",(0,n.jsx)(a.p,{children:"Validators perform two main actions in the Approval Process:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.strong,{children:(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html#assignments",children:"Assignments"})}),"\ndetermine which validators perform approval checks on which candidates, ensuring each candidate\nreceives enough random checkers. This stage tracks approval votes to identify when\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html#no-shows",children:"no-show"})," approval\nchecks take suspiciously long. It also tracks relay chain\n",(0,n.jsx)(a.a,{href:"/docs/learn-offenses#slash-for-equivocation",children:"equivocations"})," to determine when adversaries\npossibly gained foreknowledge about assignments and add more checks in those cases. Assignees\ndetermine their own assignments to check specific candidates using two or three\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html#assignment-criteria",children:"assignment criteria"}),",\nwhich are based on two possible\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html#stories",children:"stories"})," about the\nrelay chain block that included the candidate (i.e. declared the candidate available).\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html#announcements--notices",children:"Assignment notices"}),"\nare gossiped among nodes so that all validators know which validators should check which\ncandidates, and if any candidate requires more checkers."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.strong,{children:"Approval checks"})," perform the checks by obtaining the candidate, verifying its validity, sending\nout the approval vote, or initiating a dispute. Approval checks have a no-show timeout window\n(i.e. longer than one relay chain slot) to succeed in reconstructing the candidate block, redo its\nerasure coding to check the candidate receipt, and recheck the candidate block itself. A validator\nbecomes tagged as a no-show if it does not approve or dispute within the no-show timeout window.\nBecause validators can be overloaded with assignments, they can intentionally delay sending their\nassignment notice to avoid creating no-shows (see more in\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html#assignment-postponement",children:"Assignment postponement"}),")."]}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["These two steps first run as off-chain consensus protocols using messages gossiped among all\nvalidators, and then as on-chain record of those protocols' progress. The on-chain protocol is\nneeded to provide rewards for the off-chain protocol. The\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html#on-chain-verification",children:"on-chain verification"}),"\nhas two phases: a) assignments notices and approval votes are recorded in a relay chain block, and\nb) in another relay chain block notes are fed into the approval code."]}),"\n",(0,n.jsxs)(a.p,{children:["The gossiped messages are of two types, assignment notices, and approval votes, and are signed with\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html#approval-keys",children:"approval keys"}),".\nSuch keys are part of the ",(0,n.jsx)(a.a,{href:"./learn-cryptography.md/#session-keys",children:"session keys"})," used by validators.\nBriefly, approval keys are:"]}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.strong,{children:"Approval assignment keys"})," that are sr25519 keys used only for assignment criteria\n",(0,n.jsx)(a.a,{href:"/docs/learn-cryptography#vrf",children:"VRF"}),"."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.strong,{children:"Approval vote keys"})," that are ed25519 and would only sign off on a candidate parablock validity."]}),"\n"]}),"\n",(0,n.jsx)(a.admonition,{type:"info",children:(0,n.jsxs)(a.p,{children:["For detailed information about the approval process, see dedicated section in\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-approval.html",children:"The Polkadot Parachain Host Implementers' Guide"}),"."]})}),"\n",(0,n.jsx)(a.p,{children:"Accepting a parablock is the result of having passed through the detection stage without dispute, or\nhaving passed through and escalation/dispute stage with a positive outcome."}),"\n",(0,n.jsx)(a.h3,{id:"chain-selection",children:"Chain Selection"}),"\n",(0,n.jsx)(a.p,{children:"After enough secondary checks have been performed on all candidate receipts within a block,\nvalidators can vote for that block (and all previous blocks) in GRANDPA. Once the block has more\nthan 2/3 of positive votes, the block is finalized on chain."}),"\n",(0,n.jsxs)(a.p,{children:["Chain selection is used to select blocks to build on and finalize. These processes need to\nconsistent among nodes and resilient to a maximum proportion of malicious nodes. The parachain host\nuses a block authoring system and a finality gadget. The chain selection strategy involves a\n",(0,n.jsx)(a.em,{children:(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-chain-selection.html",children:"leaf-selection rule"})}),"\nand a set of\n",(0,n.jsx)(a.em,{children:(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-chain-selection.html#the-best-chain-containing-rule",children:"finality constraints"})}),"."]}),"\n",(0,n.jsx)(a.admonition,{type:"info",children:(0,n.jsxs)(a.p,{children:["For detailed information about chain selection, see dedicated section in\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-chain-selection.html",children:"The Polkadot Parachain Host Implementers' Guide"}),"."]})}),"\n",(0,n.jsx)(a.h2,{id:"candidate-receipts",children:"Candidate Receipts"}),"\n",(0,n.jsx)(a.p,{children:"PoV are typically between 1 MB and 10 MB in size and are not included in the relay chain blocks. For\nPolkadot to scale to hundreds of parachains, PoV need to be represented by something smaller on the\nrelay chain: candidate receipts. A para-validator constructs a candidate receipt for a parachain\nblock by signing:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"The parachain ID."}),"\n",(0,n.jsx)(a.li,{children:"The collator's ID and signature."}),"\n",(0,n.jsx)(a.li,{children:"A hash of the parent block's candidate receipt."}),"\n",(0,n.jsx)(a.li,{children:"A Merkle root of the block's erasure-coded pieces."}),"\n",(0,n.jsx)(a.li,{children:"A Merkle root of any outgoing messages."}),"\n",(0,n.jsx)(a.li,{children:"A hash of the block."}),"\n",(0,n.jsx)(a.li,{children:"The state root of the parachain before block execution."}),"\n",(0,n.jsx)(a.li,{children:"The state root of the parachain after block execution."}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"This information is of constant size, while the actual PoV block of the parachain can be variable\nlength. It is enough information for anyone that obtains the full PoV block to verify the state\ntransition contained inside of it."}),"\n",(0,n.jsx)(a.h2,{id:"erasure-codes",children:"Erasure Codes"}),"\n",(0,n.jsx)(a.p,{children:"Before sending the candidate receipt to the relay chain transaction queue, the para-validator who\nconstructs the receipt must also construct an erasure coding of the parachain block."}),"\n",(0,n.jsx)(a.p,{children:"An erasure coding takes a message (in this case, the parachain block and PoV) and creates a set of\nsmaller messages such that you can reconstruct the original message by obtaining a fraction of the\nsmaller messages. In the case of Polkadot, the total number of smaller messages is equal to the\ntotal number of validators and the fraction is 1/3."}),"\n",(0,n.jsx)(a.p,{children:"The para-validator creates the erasure coding chunks, puts them into their Merkle tree, and sends\nout each chunk (together with the candidate receipt) to a corresponding validator on the Relay\nChain. Validators who receive the receipts with an erasure coding chunk will include the receipt in\nthe relay chain queue, where an author can include it in a block."}),"\n",(0,n.jsxs)(a.p,{children:["The type of erasure codes used by Polkadot's availability scheme are\n",(0,n.jsx)(a.a,{href:"https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction",children:"Reed-Solomon"})," codes, which\nalready enjoy a battle-tested application in technology outside the blockchain industry. One example\nis found in the compact disk industry. CDs use Reed-Solomon codes to correct any missing data due to\ninconsistencies on the disk face such as dust particles or scratches."]}),"\n",(0,n.jsx)(a.p,{children:"In Polkadot, the erasure codes are used to keep parachain state available to the system without\nrequiring all validators to keep tabs on all the parachains. Instead, validators share smaller\npieces of the data and can later reconstruct the entire data under the assumption that 1/3+1 of the\nvalidators can provide their pieces of the data."}),"\n",(0,n.jsx)(a.admonition,{type:"note",children:(0,n.jsx)(a.p,{children:"The 1/3+1 threshold of validators that must be responsive to construct the full parachain state data\ncorresponds to Polkadot's security assumption about Byzantine nodes."})}),"\n",(0,n.jsx)(a.h2,{id:"disputes",children:"Disputes"}),"\n",(0,n.jsx)(a.p,{children:"All parachain blocks that are in the finalized relay chain should be valid. This does not apply to\nbacked blocks that are not included. To ensure nothing invalid ends up in the finalized relay chain,\nthere are approval checks (described above) and disputes. The latter ensures that each attempt to\ninclude something invalid is caught and the offending validators are punished."}),"\n",(0,n.jsxs)(a.p,{children:["False positives can happen; those actors responsible for it will be ",(0,n.jsx)(a.a,{href:"/docs/learn-offenses",children:"slashed"}),".\nTo detect false positives, PoV information must be available after the block has been included to\nthe relay chain via the ",(0,n.jsx)(a.a,{href:"#availability-and-unavailability-phase",children:"availability scheme"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["Disputes are ",(0,n.jsx)(a.em,{children:"independent from a particular fork"}),", while backing and approval operate on particular\nforks. The approval voting stops if an alternative fork (which might not contain the\ncurrently-approved candidate) is finalized. The sole purpose of the approval process is to make sure\ninvalid blocks are not finalized. However, even though the danger is past and the offending\nvalidators did not manage to get the invalid block approved, those validators need to get slashed\nfor the attempt."]}),"\n",(0,n.jsx)(a.p,{children:"A dispute stems from a disagreement between two or more validators. For this to happen, a bad actor\nneeds to distribute an invalid block to honest validators. Scenarios leading to a dispute can be one\nof the followings (ordered from most to least important):"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"A parablock included on a branch of the relay chain is bad"}),"\n",(0,n.jsx)(a.li,{children:"A parablock backed on a branch of the relay chain is bad"}),"\n",(0,n.jsx)(a.li,{children:"A parablock seconded, but not backed on any branch of the relay chain, is bad"}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"Checking a parachain block requires three pieces of data: the parachain validator code, the\navailability of data, and the candidate receipt. The validator code is available on-chain and\npublished ahead of time. Thus, a dispute process begins with the availability to ensure the\navailability of the data. Such a process will conclude quickly if the data is already available,\notherwise, the initiator of the dispute must make it available."}),"\n",(0,n.jsxs)(a.p,{children:["Disputes have both off- and on-chain components. Slashing is handled on-chain, so votes by\nvalidators on either side of the dispute must be placed on-chain. Moreover, a dispute on one branch\nof the chain must be transposed to all active branches so that misbehavior can be punished in all\npossible histories. There is, thus, a distinction between ",(0,n.jsx)(a.em,{children:"local"})," (the one we are looking at) and\n",(0,n.jsx)(a.em,{children:"remote"})," disputes relative to a particular branch of the relay chain."]}),"\n",(0,n.jsx)(a.p,{children:"Disputes can be divided into three different phases:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-disputes.html#initiation",children:"Dispute initiation"}),":\nDisputes are initiated by any validator who finds their opinion on the validity of a parablock in\nopposition to another issued statement. The initiation begins off-chain by only nodes perceiving\nthat a parablock is bad. The validator can be one of the para-validators (i.e. one of the backers)\nor one of the approval checkers. Note that if the dispute occurs during the backing phase, the\ninitiator must make the data available while if the dispute occurs during the approval process the\ndata is already available."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-disputes.html#dispute-participation",children:"Dispute participation"}),":\nOnce becoming aware of the dispute, all validators must participate."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-disputes.html#dispute-conclusion",children:"Dispute conclusion"}),":\nDisputes conclude after a 2/3 supermajority is reached on either side. Disputes may also conclude\nafter a timeout. This will only happen if the majority of validators are unable to vote for some\nreason."]}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"The on-chain component of the dispute can be initiated by providing any two conflicting votes and it\nalso waits for a 2/3 supermajority on either side. The component also tracks which parablocks have\nalready been disputed so that the same parablock can be disputed only once on any branch of the\nrelay chain. Inclusion is halted for the parachain until the dispute resolves."}),"\n",(0,n.jsx)(a.admonition,{type:"info",children:(0,n.jsxs)(a.p,{children:["For detailed information about disputes, see dedicated section in\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/protocol-disputes.html",children:"The Polkadot Parachain Host Implementers' Guide"}),".\nIn the Guide, there are also more details about\n",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/polkadot/book/disputes-flow.html",children:"disputes' flows"}),"."]})}),"\n",(0,n.jsx)(a.h2,{id:"network-asynchrony",children:"Network Asynchrony"}),"\n",(0,n.jsxs)(a.p,{children:["We have mentioned how a relay chain block author must select the candidate and note it on the Relay\nChain (we say the block is backed). The relay chain block author is selected by\n",(0,n.jsx)(a.a,{href:"/docs/learn-consensus#block-production-babe",children:"BABE"}),", which is a forkful algorithm. This means that\ndifferent block authors are chosen at the same time, and they may not work on the same block parent\n(i.e. the representations in the previous figures are simplistic). Also, the sets of validators and\nparachains are not fixed, and the validators' assignments to parachains is also flexible."]}),"\n",(0,n.jsxs)(a.p,{children:["We say that the network is ",(0,n.jsx)(a.strong,{children:"asynchronous"})," since there will be validators who have received a block\nand other validators who did not. Thus, the network is variable, and it exists in multiple states.\nIn the figure below (",(0,n.jsx)(a.em,{children:"left"}),"), Group 1 received block C while Group 2 did not due to network\nasynchrony. Validators in Group 2 can build another block on top of B, called C'. Assume that\nafterward, some validators become aware of both C and C' while others remain aware of one of them\n(",(0,n.jsx)(a.em,{children:"right"}),"). Validators in Group 3 must be aware of the network state in each head (C and C\u2019), and\nthey may contribute to some or full extent on both. It is possible that due to network asynchrony,\ntwo forks may grow in parallel for some time, but eventually, one fork will be chosen by the\nfinality gadget. In the absence of an adversarial network, it is unlikely that two forks will\ncoexist for some time as there will be validators aware of both chain heads."]}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"parachain-forks",src:i(76091).A+"",width:"1920",height:"800"})}),"\n",(0,n.jsx)(a.h2,{id:"further-resources",children:"Further Resources"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.a,{href:"https://polkadot.network/the-path-of-a-parachain-block/",children:"Path of a Parachain Block"})," - Article by\nParity analyst Joe Petrowski expounds on the validity checks that a parachain block must pass in\norder to progress the parachain."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.a,{href:"https://github.com/w3f/research/tree/85cd4adfccb7d435f21cd9fd249cd1b7f5167537/docs/papers/AnV",children:"Availability and Validity"})," -\nPaper by the W3F Research Team that specifies the availability and validity protocol in detail."]}),"\n"]})]})}function d(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},60187:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/parachain-approval-process-a025570e14282288fee420715c4e3030.png"},76091:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/parachain-forks-b3d4a4e9161292fb63e1b86888a18579.png"},45379:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/parachain-inclusion-pipeline-134e3949a7f607efc561d4992b52767c.png"},67937:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/parachain-protocol-summary-7c052aadda3eee685f56bcc65d59fc71.png"},28453:(e,a,i)=>{i.d(a,{R:()=>s,x:()=>r});var n=i(96540);const t={},o=n.createContext(t);function s(e){const a=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),n.createElement(o.Provider,{value:a},e.children)}}}]);