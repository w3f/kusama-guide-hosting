"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3377],{29320:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var t=n(74848),a=n(28453);const i={id:"learn-xcm-docs-journey-assets",title:"Trap and Claim Assets",sidebar_label:"Trap and Claim Assets",description:"Instructions to Trap and Claim Assets.",keywords:["xcm","cross-consensus messaging","trap","claim","assets"],slug:"../journey-assets"},r="Trapping and Claiming assets.",o={id:"learn/xcm/journey/learn-xcm-docs-journey-assets",title:"Trap and Claim Assets",description:"Instructions to Trap and Claim Assets.",source:"@site/../docs/learn/xcm/journey/trap-and-claim.md",sourceDirName:"learn/xcm/journey",slug:"/learn/xcm/journey-assets",permalink:"/docs/learn/xcm/journey-assets",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"bader y",lastUpdatedAt:1694099593e3,frontMatter:{id:"learn-xcm-docs-journey-assets",title:"Trap and Claim Assets",sidebar_label:"Trap and Claim Assets",description:"Instructions to Trap and Claim Assets.",keywords:["xcm","cross-consensus messaging","trap","claim","assets"],slug:"../journey-assets"},sidebar:"docs",previous:{title:"More Holding Modifiers",permalink:"/docs/learn/xcm/journey-holding"},next:{title:"Expectations",permalink:"/docs/learn/xcm/journey-expectations"}},c={},l=[{value:"Trap",id:"trap",level:2},{value:"ClaimAsset",id:"claimasset",level:2},{value:"Example",id:"example",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"trapping-and-claiming-assets",children:"Trapping and Claiming assets."})}),"\n",(0,t.jsx)(s.p,{children:"When we reach the end of the execution of the XCM there can still be assets in the Holding Register.\nWe can do nothing with them (essentially burning the assets) or we can trap the assets. When we trap\nthe assets, we keep track of the assets together with the origin of the XCM. The origin can claim\nthe assets back in one of the next XCMs. We have two instructions related to trapping and claiming\nassets:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"Trap"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"ClaimAsset"})}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"trap",children:"Trap"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"Trap(#[codec(compact)] u64)\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"Trap"})," instruction throws an error of type ",(0,t.jsx)(s.code,{children:"Trap"}),". Both the Trap instruction and Trap error take\nan ",(0,t.jsx)(s.code,{children:"u64"})," that can be used to represent some value. The Trap instruction is useful for throwing\ncustom errors. An important thing to note is that the Trap instruction does not directly trap\nassets. It can however forcefully halt the further execution of instructions and if there are still\nassets in the Holding Register, these assets can be trapped."]}),"\n",(0,t.jsx)(s.h2,{id:"claimasset",children:"ClaimAsset"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"ClaimAsset { assets: MultiAssets, ticket: MultiLocation }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Once assets are trapped, the ",(0,t.jsx)(s.code,{children:"ClaimAsset"})," instruction can be used to claim the assets. The\n",(0,t.jsx)(s.code,{children:"ClaimAsset"})," instruction has two fields."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"assets"})," field tells which trapped assets should be claimed. This must match exactly with the\nassets claimable by the origin."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"ticket"})," field is an identifier that helps locating the asset. It is, for example, useful for\ndistinguishing between Asset Versions. Lets say we have an XCM V2 trapped asset and send an XCM V3\n",(0,t.jsx)(s.code,{children:"ClaimAsset"})," instruction, then the ",(0,t.jsx)(s.code,{children:"ticket"})," field can be used to tell between the versions. In the\nxcm-pallet, ",(0,t.jsx)(s.code,{children:"Here"})," is used to describe the same version as the ",(0,t.jsx)(s.code,{children:"ClaimAsset"})," instruction, while the\n",(0,t.jsx)(s.code,{children:"GeneralIndex"})," Junction is used to describe other XCM versions."]}),"\n",(0,t.jsx)(s.h2,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(s.p,{children:["The full example can be found ",(0,t.jsx)(s.a,{href:"https://github.com/paritytech/xcm-docs/tree/main/examples",children:"here"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"The scenario of the example is this: Parachain A withdraws funds from its sovereign account on the\nrelay chain. The assets are trapped because an error is thrown and the execution is halted.\nParachain A claims the trapped assets and receives a report of the holding register."}),"\n",(0,t.jsxs)(s.p,{children:["Parachain A sends the following message to the relay chain. The message errors because of the ",(0,t.jsx)(s.code,{children:"Trap"}),"\ninstruction, so all assets in the Holding Register are trapped."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust,",metastring:"noplayground",children:"let message = Xcm(vec![\n    WithdrawAsset((Here, 10 * CENTS).into()),\n    BuyExecution { fees: (Here, CENTS).into(), weight_limit: WeightLimit::Unlimited },\n    Trap(0), // <-- Errors\n    DepositAsset { // <-- Not executed because of error.\n        assets: All.into(),\n        beneficiary: AccountId32 {\n            network: Some(parachain::RelayNetwork::get()),\n            id: ALICE.into()\n        }.into()\n    }\n]);\n"})}),"\n",(0,t.jsx)(s.p,{children:"Parachain A claims the assets, reports them to itself and deposits them in the Account of Alice."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust,",metastring:"noplayground",children:"let claim_message = Xcm(vec![\n    ClaimAsset { assets: (Here, 10 * CENTS).into(), ticket: Here.into() },\n    ReportHolding {\n        response_info: QueryResponseInfo {\n            destination: Parachain(1).into(),\n            query_id: QUERY_ID,\n            max_weight: Weight::from_parts(1_000_000_000, 64*64) },\n        assets: All.into()\n    },\n    DepositAsset {\n        assets: All.into(),\n        beneficiary: AccountId32 {\n            network: Some(parachain::RelayNetwork::get()),\n            id: ALICE.into()\n        }.into()\n    },\n]);\n"})})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>o});var t=n(96540);const a={},i=t.createContext(a);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);