"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6104],{54357:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var a=t(74848),i=t(28453);const o={id:"learn-phragmen",title:"NPoS Election Algorithms",sidebar_label:"NPoS Election Algorithms",description:"The Election Methods used in Polkadot's NPoS Mechanism.",keywords:["phragmen","sequential phragm\xe9n method","elections","algorithm","phragmms"],slug:"../learn-phragmen"},s=void 0,r={id:"learn/learn-phragmen",title:"NPoS Election Algorithms",description:"The Election Methods used in Polkadot's NPoS Mechanism.",source:"@site/../docs/learn/learn-phragmen.md",sourceDirName:"learn",slug:"/learn-phragmen",permalink:"/docs/learn-phragmen",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Filippo",lastUpdatedAt:1726760224e3,frontMatter:{id:"learn-phragmen",title:"NPoS Election Algorithms",sidebar_label:"NPoS Election Algorithms",description:"The Election Methods used in Polkadot's NPoS Mechanism.",keywords:["phragmen","sequential phragm\xe9n method","elections","algorithm","phragmms"],slug:"../learn-phragmen"},sidebar:"docs",previous:{title:"Cryptography",permalink:"/docs/learn-cryptography"},next:{title:"XCM Docs",permalink:"/docs/learn/xcm"}},d={},l=[{value:"NPoS Election Algorithms",id:"npos-election-algorithms",level:2},{value:"What is the sequential Phragm\xe9n method?",id:"what-is-the-sequential-phragm\xe9n-method",level:2},{value:"Validator Elections",id:"validator-elections",level:3},{value:"Off-Chain Phragm\xe9n",id:"off-chain-phragm\xe9n",level:4},{value:"Council Elections",id:"council-elections",level:3},{value:"What does it mean for node operators?",id:"what-does-it-mean-for-node-operators",level:2},{value:"Understanding Phragm\xe9n",id:"understanding-phragm\xe9n",level:2},{value:"Basic Phragm\xe9n",id:"basic-phragm\xe9n",level:3},{value:"Rationale",id:"rationale",level:3},{value:"Algorithm",id:"algorithm",level:3},{value:"Example",id:"example",level:3},{value:"Weighted Phragm\xe9n",id:"weighted-phragm\xe9n",level:3},{value:"Rationale",id:"rationale-1",level:3},{value:"Algorithm",id:"algorithm-1",level:3},{value:"Example",id:"example-1",level:3},{value:"Optimizations",id:"optimizations",level:2},{value:"High-Level Description",id:"high-level-description",level:3},{value:"Rationale for Minimizing the Number of Validators Per Nominator",id:"rationale-for-minimizing-the-number-of-validators-per-nominator",level:3},{value:"Rationale for Maintaining an Even Distribution of Stake",id:"rationale-for-maintaining-an-even-distribution-of-stake",level:3},{value:"Rationale for Reducing Block Computing Time",id:"rationale-for-reducing-block-computing-time",level:3},{value:"Phragmms (aka Balphragmms)",id:"phragmms-aka-balphragmms",level:3},{value:"Maximin Support Objective and PJR",id:"maximin-support-objective-and-pjr",level:4},{value:"Comparing Sequential Phragm\xe9n, MMS, and Phragmms",id:"comparing-sequential-phragm\xe9n-mms-and-phragmms",level:4},{value:"The New Election Rule: Phragmms",id:"the-new-election-rule-phragmms",level:4},{value:"Algorithm",id:"algorithm-2",level:4},{value:"External Resources",id:"external-resources",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"npos-election-algorithms",children:"NPoS Election Algorithms"}),"\n",(0,a.jsx)(n.p,{children:"Since validators are paid almost equally in in each era, it is important that the stake behind each\nvalidator is uniformly spread out. An election algorithm for Nominated Proof of Staking (NPoS) will\ntry to optimize three metrics when computing a solution graph of nominators and validators:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Maximize the total amount at stake."}),"\n",(0,a.jsx)(n.li,{children:"Maximize the stake behind the minimally staked validator."}),"\n",(0,a.jsx)(n.li,{children:"Minimize the variance of the stake in the set."}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"#understanding-phragm%C3%A9n",children:"Sequential Phragm\xe9n"}),", ",(0,a.jsx)(n.a,{href:"#phragmms-fka-balphragmms",children:"Phragmms"})," and\n",(0,a.jsx)(n.a,{href:"https://crates.parity.io/sp_npos_elections/balancing/fn.balance.html",children:"Star balancing"})," are a few\nnotable algorithms used for computing the NPoS solutions in Polkadot and Kusama."]})}),"\n",(0,a.jsx)(n.h2,{id:"what-is-the-sequential-phragm\xe9n-method",children:"What is the sequential Phragm\xe9n method?"}),"\n",(0,a.jsxs)(n.p,{children:["The sequential Phragm\xe9n method is a multi-winner election method introduced by Edvard Phragm\xe9n in\nthe 1890s. The quote below taken from the reference ",(0,a.jsx)(n.a,{href:"#external-resources",children:"Phragm\xe9n paper"})," sums up\nthe purpose of the sequential Phragm\xe9n method:"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"The problem that Phragm\xe9n\u2019s methods try to solve is that of electing a set of a given numbers of\npersons from a larger set of candidates. Phragm\xe9n discussed this in the context of a parliamentary\nelection in a multi-member constituency; the same problem can, of course, also occur in local\nelections, but also in many other situations such as electing a board or a committee in an\norganization."})}),"\n",(0,a.jsx)(n.h3,{id:"validator-elections",children:"Validator Elections"}),"\n",(0,a.jsx)(n.p,{children:"The sequential Phragm\xe9n is one of the methods used in the Nominated Proof-of-Stake scheme to elect\nvalidators based on their own self-stake and the stake that is voted to them from nominators. It\nalso tries to equalize the weights between the validators after each election round."}),"\n",(0,a.jsx)(n.h4,{id:"off-chain-phragm\xe9n",children:"Off-Chain Phragm\xe9n"}),"\n",(0,a.jsx)(n.p,{children:"Given the large set of nominators and validators, Phragm\xe9n's method is a difficult optimization\nproblem. Polkadot uses off-chain workers to compute the result off-chain and submit a transaction to\npropose the set of winners. The reason for performing this computation off-chain is to keep a\nconstant block time of six seconds and prevent long block times at the end of each era, when the\nvalidator election takes place."}),"\n",(0,a.jsx)(n.admonition,{title:"Staking Miners",type:"info",children:(0,a.jsxs)(n.p,{children:["The process of computing the optimal solution for NPoS election can be delegated to\n",(0,a.jsx)(n.a,{href:"learn-staking-miner",children:"Staking Miners"}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"council-elections",children:"Council Elections"}),"\n",(0,a.jsx)(n.admonition,{title:"Deprecated in Polkadot OpenGov",type:"info",children:(0,a.jsxs)(n.p,{children:["Phragmen was used for Council elections in ",(0,a.jsx)(n.a,{href:"/docs/learn/learn-governance",children:"Governance v1"}),"."]})}),"\n",(0,a.jsx)(n.p,{children:"The Phragm\xe9n method was also used in the council election mechanism. When you voted for council\nmembers, you could select up to 16 different candidates and then place a reserved bond as the weight\nof your vote. Phragm\xe9n would run once on every election to determine the top candidates to assume\ncouncil positions and then again amongst the top candidates to equalize the weight of the votes\nbehind them as much as possible."}),"\n",(0,a.jsx)(n.h2,{id:"what-does-it-mean-for-node-operators",children:"What does it mean for node operators?"}),"\n",(0,a.jsx)(n.p,{children:"Phragm\xe9n is something that will run in the background and requires no extra effort from you.\nHowever, it is good to understand how it works since it means that not all the stake you've been\nnominated will end up on your validator after an election. Nominators are likely to nominate a few\ndifferent validators that they trust to do a good job operating their nodes."}),"\n",(0,a.jsxs)(n.p,{children:["You can use\n",(0,a.jsx)(n.a,{href:"https://gist.github.com/tugytur/3531cc618bfbb42f1a6cfb44d9906197",children:"this offline-phragm\xe9n"})," tool for\npredicting the outcome of a validator election ahead of a new election."]}),"\n",(0,a.jsx)(n.h2,{id:"understanding-phragm\xe9n",children:"Understanding Phragm\xe9n"}),"\n",(0,a.jsx)(n.p,{children:"This section explains the sequential Phragm\xe9n method in-depth and walks through examples."}),"\n",(0,a.jsx)(n.h3,{id:"basic-phragm\xe9n",children:"Basic Phragm\xe9n"}),"\n",(0,a.jsx)(n.h3,{id:"rationale",children:"Rationale"}),"\n",(0,a.jsx)(n.p,{children:"In order to understand the Weighted Phragm\xe9n method, we must first understand the basic Phragm\xe9n\nmethod. There must be some group of candidates, a group of seats they are vying for (which is less\nthan the size of the group of candidates), and some group of voters. The voters can cast an approval\nvote - that is, they can signal approval for any subset of the candidates."}),"\n",(0,a.jsx)(n.p,{children:"The subset should be a minimum size of one (i.e., one cannot vote for no candidates) and a maximum\nsize of one less than the number of candidates (i.e., one cannot vote for all candidates). Users are\nallowed to vote for all or no candidates, but this will not affect the final result, making votes of\nthis nature meaningless."}),"\n",(0,a.jsxs)(n.p,{children:['Note that in this example, all voters are assumed to have equal say (that is, their vote does not\ncount more or less than any other votes). The weighted case will be considered later. However,\nweighting can be "simulated" by having multiple voters vote for the same slate of candidates. For\ninstance, five people voting for a particular candidate is mathematically the same as a single\nperson with weight ',(0,a.jsx)(n.code,{children:"5"})," voting for that candidate."]}),"\n",(0,a.jsxs)(n.p,{children:['The particular algorithm we call here the "Basic Phragm\xe9n" was first described by Brill ',(0,a.jsx)(n.em,{children:"et al."})," in\ntheir paper\n",(0,a.jsx)(n.a,{href:"https://ojs.aaai.org/index.php/AAAI/article/view/10598",children:'"Phragm\xe9n\u2019s Voting Methods and Justified Representation"'}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"algorithm",children:"Algorithm"}),"\n",(0,a.jsx)(n.p,{children:"The Phragm\xe9n method will iterate, selecting one seat at a time, according to the following rules:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Voters submit their ballots, marking which candidates they approve. Ballots will not be modified\nafter submission."}),"\n",(0,a.jsx)(n.li,{children:"An initial load of 0 is set for each ballot."}),"\n",(0,a.jsxs)(n.li,{children:["The candidate who wins the next available seat is the one where the ballots of their supporters\nwould have the ",(0,a.jsx)(n.em,{children:"least average (mean) cost"})," if that candidate wins."]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.em,{children:"n"})," ballots that approved that winning candidate get ",(0,a.jsx)(n.em,{children:"1/n"})," added to their load."]}),"\n",(0,a.jsx)(n.li,{children:"The load of all ballots that supported the winner of this round are averaged out so that they are\nequal."}),"\n",(0,a.jsx)(n.li,{children:"If there are any more seats, go back to step 3. Otherwise, the selection ends."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:"Let's walk through an example with four candidates vying for three seats, and five voters."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Open Seats: 3\n\nCandidates:   A B C D  L0\n-------------------------\nVoter V1:       X      0\nVoter V2:         X X  0\nVoter V3:       X   X  0\nVoter V4:     X X      0\nVoter V5:       X X X  0\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, we can see that voter ",(0,a.jsx)(n.code,{children:"V1"})," approves only of candidate ",(0,a.jsx)(n.code,{children:"B"}),", voter ",(0,a.jsx)(n.code,{children:"V2"})," approves of\ncandidates ",(0,a.jsx)(n.code,{children:"C"})," and ",(0,a.jsx)(n.code,{children:"D"}),", etc. Voters can approve any number of candidates between 1 and\n",(0,a.jsx)(n.code,{children:"number_of_candidates - 1"}),'. An initial "load" of ',(0,a.jsx)(n.code,{children:"0"})," is set for each ballot (",(0,a.jsx)(n.code,{children:"L0"})," = load after round\n",(0,a.jsx)(n.code,{children:"0"}),', i.e., the "round" before the first round). We shall see shortly how this load is updated and\nused to select candidates.']}),"\n",(0,a.jsx)(n.p,{children:'We will now run through an iterative algorithm, with each iteration corresponding to one "seat".\nSince there are three seats, we will walk through three rounds.'}),"\n",(0,a.jsxs)(n.p,{children:["For the first round, the winner is simply going to be the candidate with the most votes. Since all\nloads are equal, the lowest average load will be the candidate with the highest n, since ",(0,a.jsx)(n.code,{children:"1/n"})," will\nget smaller as ",(0,a.jsx)(n.code,{children:"n"})," increases. For this first example round, for instance, candidate ",(0,a.jsx)(n.code,{children:"A"})," had only one\nballot vote for them. Thus, the average load for candidate A is ",(0,a.jsx)(n.code,{children:"1/1"}),", or 1. Candidate C has two\nballots approving of them, so the average load is ",(0,a.jsx)(n.code,{children:"1/2"}),". Candidate B has the lowest average load, at\n",(0,a.jsx)(n.code,{children:"1/4"})," and they get the first seat. Ballots loads are now averaged out, although for the first\niteration, this will not have any effect."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Filled seats: 1 (B)\nOpen Seats: 2\n\nCandidates:   A B C D  L0 L1\n-----------------------------\nVoter V1:       X      0  1/4\nVoter V2:         X X  0  0\nVoter V3:       X   X  0  1/4\nVoter V4:     X X      0  1/4\nVoter V5:       X X X  0  1/4\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We are now down to candidates ",(0,a.jsx)(n.code,{children:"A"}),", ",(0,a.jsx)(n.code,{children:"C"}),", and ",(0,a.jsx)(n.code,{children:"D"})," for two open seats. There is only one voter (",(0,a.jsx)(n.code,{children:"V4"}),")\nfor ",(0,a.jsx)(n.code,{children:"A"}),", with load ",(0,a.jsx)(n.code,{children:"1/4"}),". ",(0,a.jsx)(n.code,{children:"C"})," has two voters, ",(0,a.jsx)(n.code,{children:"V2"})," and ",(0,a.jsx)(n.code,{children:"V5"}),", with loads of ",(0,a.jsx)(n.code,{children:"0"})," and ",(0,a.jsx)(n.code,{children:"1/4"}),". ",(0,a.jsx)(n.code,{children:"D"})," has\nthree voters approving of them, ",(0,a.jsx)(n.code,{children:"V2"}),", ",(0,a.jsx)(n.code,{children:"V3"}),", and ",(0,a.jsx)(n.code,{children:"V5"}),", with loads of ",(0,a.jsx)(n.code,{children:"0"}),", ",(0,a.jsx)(n.code,{children:"1/4"}),", and ",(0,a.jsx)(n.code,{children:"1/4"}),",\nrespectively."]}),"\n",(0,a.jsxs)(n.p,{children:["If Candidate ",(0,a.jsx)(n.code,{children:"A"})," wins, the average load would be ",(0,a.jsx)(n.code,{children:"(1/4 + 1/1) / 1"}),", or ",(0,a.jsx)(n.code,{children:"5/4"}),". If candidate ",(0,a.jsx)(n.code,{children:"C"})," wins,\nthe average load would be ",(0,a.jsx)(n.code,{children:"((0 + 1/2) + (1/4 + 1/2)) / 2"}),", or ",(0,a.jsx)(n.code,{children:"5/8"}),". If candidate ",(0,a.jsx)(n.code,{children:"D"})," wins, the\naverage load would be ",(0,a.jsx)(n.code,{children:"((0 + 1/3) + (1/4 + 1/3) + (1/4 + 1/3)) / 3"}),", or ",(0,a.jsx)(n.code,{children:"1/2"}),". Since ",(0,a.jsx)(n.code,{children:"1/2"})," is the\nlowest average load, candidate D wins the second round."]}),"\n",(0,a.jsxs)(n.p,{children:["Now everybody who voted for Candidate ",(0,a.jsx)(n.code,{children:"D"})," has their load set to the average, ",(0,a.jsx)(n.code,{children:"1/2"})," of all the loads."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Filled seats: 2 (B, D)\nOpen Seats: 1\n\nCandidates:   A B C D  L0 L1  L2\n---------------------------------\nVoter V1:       X      0  1/4 1/4\nVoter V2:         X X  0  0   1/2\nVoter V3:       X   X  0  1/4 1/2\nVoter V4:     X X      0  1/4 1/4\nVoter V5:       X X X  0  1/4 1/2\n"})}),"\n",(0,a.jsxs)(n.p,{children:["There is now one seat open and two candidates, ",(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"C"}),". Voter ",(0,a.jsx)(n.code,{children:"V4"})," is the only one voting for\n",(0,a.jsx)(n.code,{children:"A"}),", so if ",(0,a.jsx)(n.code,{children:"A"})," wins then the average load would be ",(0,a.jsx)(n.code,{children:"(1/4 + 1/1) / 1"}),", or ",(0,a.jsx)(n.code,{children:"5/4"}),". Voters ",(0,a.jsx)(n.code,{children:"V2"})," and ",(0,a.jsx)(n.code,{children:"V5"}),"\n(both with load ",(0,a.jsx)(n.code,{children:"1/2"}),") support ",(0,a.jsx)(n.code,{children:"C"}),", so if ",(0,a.jsx)(n.code,{children:"C"})," wins the average load would be\n",(0,a.jsx)(n.code,{children:"((1/2 + 1/2) + (1/2 + 1/2)) / 2"}),", or ",(0,a.jsx)(n.code,{children:"1"}),". Since the average load would be lower with ",(0,a.jsx)(n.code,{children:"C"}),", ",(0,a.jsx)(n.code,{children:"C"})," wins\nthe final seat."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Filled seats: 3 (B, D, C)\nOpen Seats: 0\n\nCandidates:   A B C D  L0 L1  L2  L3\n------------------------------------\nVoter V1:       X      0  1/4 1/4 1/4\nVoter V2:         X X  0  0   1/2 1\nVoter V3:       X   X  0  1/4 1/2 1/2\nVoter V4:     X X      0  1/4 1/4 1/4\nVoter V5:       X X X  0  1/4 1/2 1\n"})}),"\n",(0,a.jsxs)(n.p,{children:["An interesting characteristic of this calculation is that the total load of all voters will always\nequal the number of seats filled in that round. In the zeroth round, load starts at ",(0,a.jsx)(n.code,{children:"0"})," and there\nare no seats filled. After the first round, the total of all loads is ",(0,a.jsx)(n.code,{children:"1"}),", after the second round it\nis ",(0,a.jsx)(n.code,{children:"2"}),", etc."]}),"\n",(0,a.jsx)(n.h3,{id:"weighted-phragm\xe9n",children:"Weighted Phragm\xe9n"}),"\n",(0,a.jsx)(n.h3,{id:"rationale-1",children:"Rationale"}),"\n",(0,a.jsx)(n.p,{children:"While this method works well if all voters have equal weight, this is not the case in Polkadot.\nElections for both validators and candidates for the Council are weighted by the number of tokens\nheld by the voters. This makes elections more similar to a corporate shareholder election than a\ntraditional political election, where some members have more pull than others. Someone with a single\ntoken will have much less voting power than someone with 100. Although this may seem\nanti-democratic, in a pseudonymous system, it is trivial for someone with 100 tokens to create 100\ndifferent accounts and spread their wealth to all of their pseudonyms."}),"\n",(0,a.jsx)(n.p,{children:"Therefore, not only do we want to allow voters to have their preferences expressed in the result,\nbut do so while keeping as equal a distribution of their stake as possible and express the wishes of\nminorities as much as is possible. The Weighted Phragm\xe9n method allows us to reach these goals."}),"\n",(0,a.jsx)(n.h3,{id:"algorithm-1",children:"Algorithm"}),"\n",(0,a.jsx)(n.p,{children:"Weighted Phragm\xe9n is similar to Basic Phragm\xe9n in that it selects candidates sequentially, one per\nround, until the maximum number of candidates are elected. However, it has additional features to\nalso allocate weight (stake) behind the candidates."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:'NOTE: in terms of validator selection, for the following algorithm, you can think of "voters" as\n"nominators" and "candidates" as "validators".'})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:'Candidates are elected, one per round, and added to the set of successful candidates (they have\nwon a "seat"). This aspect of the algorithm is very similar to the "basic Phragm\xe9n" algorithm\ndescribed above.'}),"\n",(0,a.jsx)(n.li,{children:"However, as candidates are elected, a weighted mapping is built, defining the weights of each\nselection of a validator by each nominator."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In more depth, the algorithm operates like so:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Create a list of all voters, their total amount of stake, and which validators they support."}),"\n",(0,a.jsxs)(n.li,{children:["Generate an initial edge-weighted graph mapping from voters to candidates, where each edge weight\nis the total ",(0,a.jsx)(n.em,{children:"potential"})," weight (stake) given by that voter. The sum of all potential weight for\na given candidate is called their ",(0,a.jsx)(n.em,{children:"approval stake"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Now we start electing candidates. For the list of all candidates who have not been elected, get\ntheir score, which is equal to ",(0,a.jsx)(n.code,{children:"1 / approval_stake"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["For each voter, update the score of each candidate they support by adding their total budget\n(stake) multiplied by the load of the voter and then dividing by that candidate's approval stake\n",(0,a.jsx)(n.code,{children:"(voter_budget * voter_load / candidate_approval_stake)"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Determine the candidate with the lowest score and elect that candidate. Remove the elected\ncandidate from the pool of potential candidates."}),"\n",(0,a.jsx)(n.li,{children:"The load for each edge connecting to the winning candidate is updated, with the edge load set to\nthe score of the candidate minus the voter's load, and the voter's load then set to the\ncandidate's score."}),"\n",(0,a.jsx)(n.li,{children:"If there are more candidates to elect, go to Step 3. Otherwise, continue to step 8."}),"\n",(0,a.jsxs)(n.li,{children:["Now the stake is distributed amongst each nominator who backed at least one elected candidate.\nThe backing stake for each candidate is calculated by taking the budget of the voter and\nmultiplying by the edge load then dividing by the candidate load\n(",(0,a.jsx)(n.code,{children:"voter_budget * edge_load / candidate_load"}),")."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Note: All numbers in this example are rounded off to three decimal places."})}),"\n",(0,a.jsxs)(n.p,{children:["In the following example, there are five voters and five candidates vying for three potential seats.\nEach voter ",(0,a.jsx)(n.code,{children:"V1 - V5"})," has an amount of stake equal to their number (e.g., ",(0,a.jsx)(n.code,{children:"V1"})," has stake of 1, ",(0,a.jsx)(n.code,{children:"V2"}),"\nhas stake of 2, etc.). Every voter is also going to have a ",(0,a.jsx)(n.em,{children:"load,"})," which initially starts at ",(0,a.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Filled seats: 0\nOpen Seats: 3\n\nCandidates:    A B C D E  L0\n----------------------------\nVoter V1 (1):  X X        0\nVoter V2 (2):  X X        0\nVoter V3 (3):  X          0\nVoter V4 (4):    X X X    0\nVoter V5 (5):  X     X    0\n"})}),"\n",(0,a.jsx)(n.p,{children:"Let us now calculate the approval stake of each of the candidates. Recall that this is merely the\namount of all support for that candidate by all voters."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Candidate A: 1 + 2 + 3 + 5 = 11\nCandidate B: 1 + 2 + 4 = 7\nCandidate C: 4 = 4\nCandidate D: 4 + 5 = 9\nCandidate E: 0\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The first step is easy - candidate ",(0,a.jsx)(n.code,{children:"E"})," has 0 approval stake and can be ignored from here on out.\nThey will never be elected."]}),"\n",(0,a.jsxs)(n.p,{children:["We can now calculate the initial scores of the candidates, which is ",(0,a.jsx)(n.code,{children:"1 / approval_stake"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Candidate A: 1 / 11 = 0.091\nCandidate B: 1 / 7 = 0.143\nCandidate C: 1 / 4 = 0.25\nCandidate D: 1 / 9 = 0.111\nCandidate E: N/A\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For every edge, we are going to calculate the score, which is current score plus the total budget *\nthe load of the voter divided by the approval stake of the candidate. However, since the load of\nevery voter starts at 0, and anything multiplied by 0 is 0, any addition will be ",(0,a.jsx)(n.code,{children:"0 / x"}),", or 0. This\nmeans that this step can be safely ignored for the initial round."]}),"\n",(0,a.jsxs)(n.p,{children:["Thus, the best (lowest) score for Round 0 is Candidate A, with a score of ",(0,a.jsx)(n.code,{children:"0.091"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Candidates:    A B C D E  L0 L1\n----------------------------------\nVoter V1 (1):  X X        0  0.091\nVoter V2 (2):  X X        0  0.091\nVoter V3 (3):  X          0  0.091\nVoter V4 (4):    X X X    0  0\nVoter V5 (5):  X     X    0  0.091\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Filled seats: 1 (A)\nOpen Seats: 2\n\nCandidates:    A B C D E  L0\n----------------------------\nVoter V1 (1):  X X        0\nVoter V2 (2):  X X        0\nVoter V3 (3):  X          0\nVoter V4 (4):    X X X    0\nVoter V5 (5):  X     X    0\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Candidate ",(0,a.jsx)(n.code,{children:"A"})," is now safe; there is no way that they will lose their seat. Before moving on to the\nnext round, we need to update the scores on the edges of our graph for any candidates who have not\nyet been elected."]}),"\n",(0,a.jsx)(n.p,{children:"We elided this detail in the previous round, since it made no difference to the final scores, but we\nshould go into depth here to see how scores are updated. We first must calculate the new loads of\nthe voters, and then calculate the new scores of the candidates."}),"\n",(0,a.jsxs)(n.p,{children:["Any voter who had one of their choices for candidate fill the seat in this round (i.e., voters ",(0,a.jsx)(n.code,{children:"V1"}),",\n",(0,a.jsx)(n.code,{children:"V2"}),", ",(0,a.jsx)(n.code,{children:"V3"}),", and ",(0,a.jsx)(n.code,{children:"V5"}),", who all voted for ",(0,a.jsx)(n.code,{children:"A"}),") will have their load increased. This load increase will\nblunt the impact of their vote in future rounds, and the edge (which will be used in determining\nstake allocation later) is set to the score of the elected candidate minus the ",(0,a.jsx)(n.em,{children:"current"})," voter load."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"edge_load = elected_candidate_score - voter_load\nvoter_load = elected_candidate_score\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this instance, the score of the elected candidate is ",(0,a.jsx)(n.code,{children:"0.091"})," and the voter loads are all ",(0,a.jsx)(n.code,{children:"0"}),". So\nfor each voter who voted for ",(0,a.jsx)(n.code,{children:"A"}),", we will calculate a new edge load ",(0,a.jsx)(n.code,{children:"Voter"})," -> ",(0,a.jsx)(n.code,{children:"A"})," of:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Edge load: 0.091 - 0 = 0.091\n"})}),"\n",(0,a.jsx)(n.p,{children:"and a new voter load of:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Voter load: 0.091\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As a reminder, here are the current scores. Loads of the voters are all ",(0,a.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Candidate B : 0.143\nCandidate C : 0.25\nCandidate D : 0.111\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now, we go through the weighted graph and update the score of the candidate and the load of the\nedge, using the algorithm:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"candidate_score = candidate_score + ((voter_budget * voter_load) / candidate_approval_stake)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Without walking through each step, this gives us the following modifications to the scores of the\ndifferent candidates."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"V1 updates B to 0.156\nV2 updates B to 0.182\nV4 updates B to 0.182\nV4 updates C to 0.25\nV4 updates D to 0.111\nV5 updates D to 0.162\n"})}),"\n",(0,a.jsx)(n.p,{children:"After scores are updated, the final scores for the candidates for this round are:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Candidate B: 0.182\nCandidate C: 0.25\nCandidate D: 0.162\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"D"}),", with the lowest score, is elected. You will note that even though candidate ",(0,a.jsx)(n.code,{children:"B"})," had more voters\nsupporting them, candidate ",(0,a.jsx)(n.code,{children:"D"})," won the election due to their lower score. This is directly due to\nthe fact that they had the lowest score, of course, but the root reason behind them having a lower\nscore was both the greater amount of stake behind them and that voters who did not get one of their\nchoices in an earlier round (in this example, voter V4) correspond to a higher likelihood of a\ncandidate being elected."]}),"\n",(0,a.jsxs)(n.p,{children:["We then update the loads for the voters and edges as specified above for any voters who voted for\ncandidate ",(0,a.jsx)(n.code,{children:"D"})," (viz., ",(0,a.jsx)(n.code,{children:"V4"})," and ",(0,a.jsx)(n.code,{children:"V5"}),") using the same formula as above."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Filled seats: 2 (A, D)\nOpen Seats: 1\n\nCandidates:    A B C D E  L0 L1    L2\n-----------------------------------\nVoter V1 (1):  X X        0  0.091 0.091\nVoter V2 (2):  X X        0  0.091 0.091\nVoter V3 (3):  X          0  0.091 0.091\nVoter V4 (4):    X X X    0  0     0.162\nVoter V5 (5):  X     X    0  0.091 0.162\n"})}),"\n",(0,a.jsx)(n.p,{children:"Following a similar process for Round 2, we start with initial candidate scores of:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Candidate B : 0.143\nCandidate C : 0.25\n"})}),"\n",(0,a.jsx)(n.p,{children:"We can then update the scores of the remaining two candidates according to the algorithm described\nabove."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"V1 updates B to 0.156\nV2 updates B to 0.182\nV4 updates B to 0.274\nV4 updates C to 0.412\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With the lowest score of ",(0,a.jsx)(n.code,{children:"0.274"}),", Candidate ",(0,a.jsx)(n.code,{children:"B"})," claims the last open seat. Candidates ",(0,a.jsx)(n.code,{children:"A"}),", ",(0,a.jsx)(n.code,{children:"D"}),", and\n",(0,a.jsx)(n.code,{children:"B"})," have been elected, and candidates ",(0,a.jsx)(n.code,{children:"C"})," and ",(0,a.jsx)(n.code,{children:"E"})," are not."]}),"\n",(0,a.jsx)(n.p,{children:"Before moving on, we must perform a final load adjustment for the voters and the graph."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Filled seats: 3 (A, D, B)\nOpen Seats: 0\n\nCandidates:    A B C D E  L0 L1    L2    L3\n------------------------------------------\nVoter V1 (1):  X X        0  0.091 0.091 0.274\nVoter V2 (2):  X X        0  0.091 0.091 0.274\nVoter V3 (3):  X          0  0.091 0.091 0.091\nVoter V4 (4):    X X X    0  0     0.162 0.274\nVoter V5 (5):  X     X    0  0.091 0.162 0.162\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now we have to determine how much stake every voter should allocate to each candidate. This is done\nby taking the load of the each edge and dividing it by the voter load, then multiplying by the total\nbudget of the voter."}),"\n",(0,a.jsx)(n.p,{children:"In this example, the weighted graph ended up looking like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Nominator: V1\n\tEdge to A load= 0.091\n\tEdge to B load= 0.183\nNominator: V2\n\tEdge to A load= 0.091\n\tEdge to B load= 0.183\nNominator: V3\n\tEdge to A load= 0.091\nNominator: V4\n\tEdge to B load= 0.113\n\tEdge to D load= 0.162\nNominator: V5\n\tEdge to A load= 0.091\n\tEdge to D load= 0.071\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For instance, the budget of ",(0,a.jsx)(n.code,{children:"V1"})," is ",(0,a.jsx)(n.code,{children:"1"}),", the edge load to ",(0,a.jsx)(n.code,{children:"A"})," is ",(0,a.jsx)(n.code,{children:"0.091"}),", and the voter load is\n",(0,a.jsx)(n.code,{children:"0.274"}),". Using our equation:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"backing_stake (A) = voter_budget * edge_load / voter_load\n"})}),"\n",(0,a.jsx)(n.p,{children:"We can fill these variables in with:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"backing_stake (A) = 1 * 0.091 / 0.274 = 0.332\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For ",(0,a.jsx)(n.code,{children:"V1"})," backing stake of ",(0,a.jsx)(n.code,{children:"B"}),", you can simply replace the edge load value and re-calculate."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"backing_stake (B) = 1 * 0.183 / 0.274 = 0.668\n"})}),"\n",(0,a.jsx)(n.p,{children:"Note that the total amount of all backing stake for a given voter will equal the total budget of the\nvoter, unless that voter had no candidates elected, in which case it will be 0."}),"\n",(0,a.jsx)(n.p,{children:"The final results are:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"A is elected with stake 6.807.\nD is elected with stake 4.545.\nB is elected with stake 3.647.\n\nV1 supports: A with stake: 0.332 and B with stake: 0.668.\nV2 supports: A with stake: 0.663 and B with stake: 1.337.\nV3 supports: A with stake: 3.0.\nV4 supports: B with stake: 1.642 and D with stake: 2.358.\nV5 supports: A with stake: 2.813 and D with stake: 2.187.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You will notice that the total amount of stake for candidates ",(0,a.jsx)(n.code,{children:"A"}),", ",(0,a.jsx)(n.code,{children:"D"}),", and ",(0,a.jsx)(n.code,{children:"B"})," equals (aside from\nrounding errors) the total amount of stake of all the voters (",(0,a.jsx)(n.code,{children:"1 + 2 + 3 + 4 + 5 = 15"}),"). This is\nbecause each voter had at least one of their candidates fill a seat. Any voter who had none of their\ncandidates selected will also not have any stake in any of the elected candidates."]}),"\n",(0,a.jsx)(n.h2,{id:"optimizations",children:"Optimizations"}),"\n",(0,a.jsx)(n.p,{children:"The results for nominating validators are further optimized for several purposes:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"To reduce the number of edges, i.e. to minimize the number of validators any nominator selects"}),"\n",(0,a.jsx)(n.li,{children:"To ensure, as much as possible, an even distribution of stake among the validators"}),"\n",(0,a.jsx)(n.li,{children:"Reduce the amount of block computation time"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"high-level-description",children:"High-Level Description"}),"\n",(0,a.jsx)(n.p,{children:"After running the weighted Phragm\xe9n algorithm, a process is run that redistributes the vote amongst\nthe elected set. This process will never add or remove an elected candidate from the set. Instead,\nit reduces the variance in the list of backing stake from the voters to the elected candidates.\nPerfect equalization is not always possible, but the algorithm attempts to equalize as much as\npossible. It then runs an edge-reducing algorithm to minimize the number of validators per\nnominator, ideally giving every nominator a single validator to nominate per era."}),"\n",(0,a.jsxs)(n.p,{children:["To minimize block computation time, the staking process is run as an\n",(0,a.jsx)(n.a,{href:"https://docs.substrate.io/reference/how-to-guides/offchain-workers/",children:"off-chain worker"}),". In order to\ngive time for this off-chain worker to run, staking commands (bond, nominate, etc.) are not allowed\nin the last quarter of each era."]}),"\n",(0,a.jsxs)(n.p,{children:["These optimizations will not be covered in-depth on this page. For more details, you can view the\n",(0,a.jsx)(n.a,{href:"https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame/elections-phragmen/src/lib.rs",children:"Rust implementation of elections in Substrate"}),",\nthe\n",(0,a.jsx)(n.a,{href:"https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame/staking/src/lib.rs",children:"Rust implementation of staking in Substrate"}),",\nor the ",(0,a.jsx)(n.code,{children:"seqPhragm\xe9nwithpostprocessing"})," method in the\n",(0,a.jsx)(n.a,{href:"https://github.com/w3f/consensus/tree/master/NPoS",children:"Python reference implementation"}),". If you would\nlike to dive even more deeply, you can review the\n",(0,a.jsx)(n.a,{href:"https://research.web3.foundation/Polkadot/protocols/NPoS/Overview#the-election-process",children:"W3F Research Page on Sequential Phragm\xe9n Method"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"rationale-for-minimizing-the-number-of-validators-per-nominator",children:"Rationale for Minimizing the Number of Validators Per Nominator"}),"\n",(0,a.jsxs)(n.p,{children:["Paying out rewards for staking from every validator to all of their nominators can cost a\nnon-trivial amount of chain resources (in terms of space on chain and resources to compute). Assume\na system with 200 validators and 1000 nominators, where each of the nominators has nominated 10\ndifferent validators. Payout would thus require ",(0,a.jsx)(n.code,{children:"1_000 * 10"}),", or 10_000 transactions. In an ideal\nscenario, if every nominator selects a single validator, only 1_000 transactions would need to take\nplace - an order of magnitude fewer. Empirically, network slowdown at the beginning of an era has\noccurred due to the large number of individual payouts by validators to nominators. In extreme\ncases, this could be an attack vector on the system, where nominators nominate many different\nvalidators with small amounts of stake in order to slow the system at the next era change."]}),"\n",(0,a.jsxs)(n.p,{children:["While this would reduce network and on-chain load, being able to select only a single validator\nincurs some diversification costs. If the single validator that a nominator has nominated acts\nmaliciously, then the nominator incurs a risk of a significant amount of\n",(0,a.jsx)(n.a,{href:"/docs/learn-offenses",children:"slashing"}),". Nominators are thus allowed to nominate up to 16 different\nvalidators. However, after the weighted edge-reducing algorithm is run, the number of validators per\nnominator is minimized. Nominators are likely to see themselves nominating a single active validator\nfor an era."]}),"\n",(0,a.jsx)(n.p,{children:"At each era change, as the algorithm runs again, nominators are likely to have a different validator\nthan they had before (assuming a significant number of selected validators). Therefore, nominators\ncan diversify against incompetent or corrupt validators causing slashing on their accounts, even if\nthey only nominate a single validator per era."}),"\n",(0,a.jsx)(n.h3,{id:"rationale-for-maintaining-an-even-distribution-of-stake",children:"Rationale for Maintaining an Even Distribution of Stake"}),"\n",(0,a.jsxs)(n.p,{children:["Another issue is that we want to ensure that as equal a distribution of votes as possible amongst\nthe elected validators or council members. This helps us increase the security of the system by\nensuring that the minimum amount of tokens in order to join the active validator set or council is\nas high as possible. For example, assume a result of five validators being elected, where validators\nhave the following stake: ",(0,a.jsx)(n.code,{children:"{1_000, 20, 10, 10, 10}"}),', for a total stake of 1_050. In this case, a\npotential attacker could join the active validator set with only 11 tokens, and could obtain a\nmajority of validators with only 33 tokens (since the attacker only has to have enough stake to\n"kick out" the three lowest validators).']}),"\n",(0,a.jsxs)(n.p,{children:["In contrast, imagine a different result with the same amount of total stake, but with that stake\nperfectly equally distributed: ",(0,a.jsx)(n.code,{children:"{210, 210, 210, 210, 210}"}),". With the same amount of stake, an\nattacker would need to stake 633 tokens in order to get a majority of validators, a much more\nexpensive proposition. Although obtaining an equal distribution is unlikely, the more equal the\ndistribution, the higher the threshold - and thus the higher the expense - for attackers to gain\nentry to the set."]}),"\n",(0,a.jsx)(n.h3,{id:"rationale-for-reducing-block-computing-time",children:"Rationale for Reducing Block Computing Time"}),"\n",(0,a.jsx)(n.p,{children:"Running the Phragm\xe9n algorithm is time-consuming, and often cannot be completed within the time\nlimits of production of a single block. Waiting for calculation to complete would jeopardize the\nconstant block production time of the network. Therefore, as much computation as possible is moved\nto an off-chain worker, which validators can work on the problem without impacting block production\ntime."}),"\n",(0,a.jsxs)(n.p,{children:["To limit the complexity of the election and payout, any given nominator can only\n",(0,a.jsx)(n.a,{href:"/docs/chain-state-values#maximum-votes-per-nominator",children:"select a limited number of validators"}),"\nto nominate."]}),"\n",(0,a.jsx)(n.h3,{id:"phragmms-aka-balphragmms",children:"Phragmms (aka Balphragmms)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Phragmms"}),", formerly known as ",(0,a.jsx)(n.code,{children:"Balphragmms"}),", is a new election rule inspired by Phragm\xe9n and\ndeveloped in-house for Polkadot. In general, election rules on blockchains is an active topic of\nresearch. This is due to the conflicting requirements for election rules and blockchains: elections\nare computationally expensive, but blockchains are computationally limited. Thus, this work\nconstitutes state of the art in terms of optimization."]}),"\n",(0,a.jsxs)(n.p,{children:["Proportional representation is a very important property for a decentralized network to have in\norder to maintain a sufficient level of decentralization. While this is already provided by the\ncurrently implemented ",(0,a.jsx)(n.code,{children:"seqPhragmen"}),", this new election rule provides the advantage of the added\nsecurity guarantee described below. As far as we can tell, at the time of writing, Polkadot and\nKusama are the only blockchain networks that implement an election rule that guarantees proportional\nrepresentation."]}),"\n",(0,a.jsxs)(n.p,{children:["The security of a distributed and decentralized system such as Polkadot is directly related to the\ngoal of avoiding ",(0,a.jsx)(n.em,{children:"overrepresentation"})," of any minority. This is a stark contrast to traditional\napproaches to proportional representation axioms, which typically only seek to avoid\nunderrepresentation."]}),"\n",(0,a.jsx)(n.h4,{id:"maximin-support-objective-and-pjr",children:"Maximin Support Objective and PJR"}),"\n",(0,a.jsxs)(n.p,{children:["This new election rule aims to achieve a constant-factor approximation guarantee for the ",(0,a.jsx)(n.em,{children:"maximin\nsupport objective"})," and the closely related ",(0,a.jsx)(n.em,{children:"proportional justified representation"})," (PJR) property."]}),"\n",(0,a.jsxs)(n.p,{children:["The maximin support objective is based on maximizing the support of the least-supported elected\ncandidate, or in the case of Polkadot and Kusama, maximizing the least amount of stake backing\namongst elected validators. This security-based objective translates to a security guarantee for\nNPoS and makes it difficult for an adversarial whale\u2019s validator nodes to be elected. The ",(0,a.jsx)(n.code,{children:"Phragmms"}),"\nrule, and the guarantees it provides in terms of security and proportionality, have been formalized\nin a ",(0,a.jsx)(n.a,{href:"https://arxiv.org/pdf/2004.12990.pdf",children:"peer-reviewed paper"}),")."]}),"\n",(0,a.jsx)(n.p,{children:"The PJR property considers the proportionality of the voter\u2019s decision power. The property states\nthat a group of voters with cohesive candidate preferences and a large enough aggregate voting\nstrength deserve to have a number of representatives proportional to the group\u2019s vote strength."}),"\n",(0,a.jsx)(n.h4,{id:"comparing-sequential-phragm\xe9n-mms-and-phragmms",children:"Comparing Sequential Phragm\xe9n, MMS, and Phragmms"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"Sequential Phragm\xe9n"})," (",(0,a.jsx)(n.code,{children:"seqPhragmen"}),") and ",(0,a.jsx)(n.code,{children:"MMS"})," are two efficient election rules that both achieve\nPJR."]}),"\n",(0,a.jsxs)(n.p,{children:["Currently, Polkadot employs the ",(0,a.jsx)(n.code,{children:"seqPhragmen"})," method for validator and council elections. Although\n",(0,a.jsx)(n.code,{children:"seqPhramen"})," has a very fast runtime, it does not provide constant-factor approximation for the\nmaximin support problem. This is due to ",(0,a.jsx)(n.code,{children:"seqPhramen"})," only performing an ",(0,a.jsx)(n.em,{children:"approximate"})," rebalancing of\nthe distribution of stake."]}),"\n",(0,a.jsxs)(n.p,{children:["In contrast, ",(0,a.jsx)(n.code,{children:"MMS"})," is another standard greedy algorithm that simultaneously achieves the PJR\nproperty and provides a constant factor approximation for maximin support, although with a\nconsiderably slower runtime. This is because for a given partial solution, ",(0,a.jsx)(n.code,{children:"MMS"})," computes a balanced\nedge weight vector for each possible augmented committee when a new candidate is added, which is\ncomputationally expensive."]}),"\n",(0,a.jsxs)(n.p,{children:["We introduce a new heuristic inspired by ",(0,a.jsx)(n.code,{children:"seqPhragmen"}),", ",(0,a.jsx)(n.code,{children:"PhragMMS"}),", which maintains a comparable\nruntime to ",(0,a.jsx)(n.code,{children:"seqPhragmen"}),", offers a constant-factor approximation guarantee for the maximin support\nobjective, and satisfies PJR. This is the fastest known algorithm to achieve a constant-factor\nguarantee for maximin support."]}),"\n",(0,a.jsx)(n.h4,{id:"the-new-election-rule-phragmms",children:"The New Election Rule: Phragmms"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Phragmms"})," is an iterative greedy algorithm that starts with an empty committee and alternates\nbetween the ",(0,a.jsx)(n.code,{children:"Phragmms"})," heuristic for inserting a new candidate and ",(0,a.jsx)(n.em,{children:"rebalancing"})," by replacing the\nweight vector with a balanced one. The main differentiator between ",(0,a.jsx)(n.code,{children:"Phragmms"})," and ",(0,a.jsx)(n.code,{children:"seqPhragmen"})," is\nthat the latter only perform an approximate rebalancing. Details can be found in\n",(0,a.jsx)(n.a,{href:"#rationale-for-maintaining-an-even-distribution-of-stake",children:"Balanced Stake Distribution"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The computation is executed by off-chain workers privately and separately from block production, and\nthe validators only need to submit and verify the solutions on-chain. Relative to a committee ",(0,a.jsx)(n.em,{children:"A"}),",\nthe score of an unelected candidate ",(0,a.jsx)(n.em,{children:"c"})," is an easy-to-compute rough estimate of what would be the\nsize of the least stake backing if we added ",(0,a.jsx)(n.em,{children:"c"})," to committee ",(0,a.jsx)(n.em,{children:"A"}),". Observing on-chain, only one\nsolution needs to be tracked at any given time, and a block producer can submit a new solution in\nthe block only if the block passes the verification test, consisting of checking:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Feasibility,"}),"\n",(0,a.jsx)(n.li,{children:"Balance and"}),"\n",(0,a.jsxs)(n.li,{children:["Local Optimality - The least stake backing of ",(0,a.jsx)(n.em,{children:"A"})," is higher than the highest score among\nunelected candidates"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"If the tentative solution passes the tests, then it replaces the current solution as the tentative\nwinner. The official winning solution is declared at the end of the election window."}),"\n",(0,a.jsxs)(n.p,{children:["A powerful feature of this algorithm is the fact that both its approximation guarantee for maximin\nsupport and the above checks passing can be efficiently verified in linear time. This allows for a\nmore scalable solution for secure and proportional committee elections. While ",(0,a.jsx)(n.code,{children:"seqPhragmen"})," also has\na notion of score for unelected candidates, ",(0,a.jsx)(n.code,{children:"Phragmms"})," can be seen as a natural complication of the\n",(0,a.jsx)(n.code,{children:"seqPhragmen"})," algorithm, where ",(0,a.jsx)(n.code,{children:"Phragmms"})," always grants higher score values to candidates and thus\ninserts them with higher support values."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"To summarize, the main differences between the two rules are:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["In ",(0,a.jsx)(n.code,{children:"seqPhragmen"}),", lower scores are better, whereas in ",(0,a.jsx)(n.code,{children:"Phragmms"}),", higher scores are better."]}),"\n",(0,a.jsxs)(n.li,{children:["Inspired by ",(0,a.jsx)(n.code,{children:"seqPhragmen"}),", the scoring system of ",(0,a.jsx)(n.code,{children:"Phragmms"})," can be considered to be more intuitive\nand does a better job at estimating the value of adding a candidate to the current solution, and\nhence leads to a better candidate-selection heuristic."]}),"\n",(0,a.jsxs)(n.li,{children:["Unlike ",(0,a.jsx)(n.code,{children:"seqPhragmen"}),", in ",(0,a.jsx)(n.code,{children:"Phragmms"}),", the edge weight vector ",(0,a.jsx)(n.em,{children:"w"})," is completely rebalanced after\neach iteration of the algorithm."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Phragmms"})," election rule is currently being implemented on Polkadot. Once completed, it will\nbecome one of the most sophisticated election rules implemented on a blockchain. For the first time,\nthis election rule will provide both fair representation (PJR) and security (constant-factor\napproximation for the maximin support objection) to a blockchain network."]}),"\n",(0,a.jsx)(n.h4,{id:"algorithm-2",children:"Algorithm"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Phragmms"})," algorithm iterates through the available seats, starting with an empty committee of\nsize ",(0,a.jsx)(n.em,{children:"k"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Initialize an empty committee ",(0,a.jsx)(n.em,{children:"A"})," and zero edge weight vector ",(0,a.jsx)(n.em,{children:"w = 0"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Repeat ",(0,a.jsx)(n.em,{children:"k"})," times:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Find the unelected candidate with highest score and add it to committee ",(0,a.jsx)(n.em,{children:"A"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Re-balance the weight vector ",(0,a.jsx)(n.em,{children:"w"})," for the new committee ",(0,a.jsx)(n.em,{children:"A"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Return ",(0,a.jsx)(n.em,{children:"A"})," and ",(0,a.jsx)(n.em,{children:"w"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"external-resources",children:"External Resources"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://arxiv.org/pdf/2004.12990.pdf",children:"Phragmms"})," - W3F research paper that expands on the\nsequential Phragm\xe9n method."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://research.web3.foundation/Polkadot/protocols/NPoS/Overview",children:"W3F Research Page on NPoS"})," -\nAn overview of Nominated Proof of Stake as its applied to Polkadot."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://github.com/w3f/consensus/tree/master/NPoS",children:"Python Reference Implementations"})," - Python\nimplementations of Simple and Complicated Phragm\xe9n methods."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame/staking/src/lib.rs",children:"Substrate Implementation"})," -\nRust implementation used in Substrate."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://arxiv.org/pdf/1611.08826.pdf",children:"Phragm\xe9n's and Thiele's Election Methods"})," - 95-page paper\nexplaining Phragm\xe9n's election methods in detail."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://ojs.aaai.org/index.php/AAAI/article/view/10598",children:"Phragm\xe9n\u2019s Voting Methods and Justified Representation"})," -\nThis paper by Brill ",(0,a.jsx)(n.em,{children:"et al."})," is the source for the simple Phragm\xe9n method, along with proofs about\nits properties."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://github.com/kianenigma/offline-phragmen",children:"Offline Phragm\xe9n"})," - Script to generate the\nPhragm\xe9n validator election outcome before the start of an era."]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(96540);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);