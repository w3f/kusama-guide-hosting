"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4841],{99027:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>i});var t=s(74848),c=s(28453);const a={id:"learn-xcm-docs-journey-locks",title:"Locks",sidebar_label:"Locks",description:"Restrict Transfer or Withdrawal of Assets.",keywords:["xcm","cross-consensus messaging","locks"],slug:"../../journey-locks"},o="Locking",l={id:"learn/xcm/journey/locks/learn-xcm-docs-journey-locks",title:"Locks",description:"Restrict Transfer or Withdrawal of Assets.",source:"@site/../docs/learn/xcm/journey/locks/locks.md",sourceDirName:"learn/xcm/journey/locks",slug:"/learn/xcm/journey-locks",permalink:"/docs/learn/xcm/journey-locks",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"bader y",lastUpdatedAt:1694099593e3,frontMatter:{id:"learn-xcm-docs-journey-locks",title:"Locks",sidebar_label:"Locks",description:"Restrict Transfer or Withdrawal of Assets.",keywords:["xcm","cross-consensus messaging","locks"],slug:"../../journey-locks"},sidebar:"docs",previous:{title:"Version Subscription",permalink:"/docs/learn/xcm/journey-version"},next:{title:"Channels and Bridges",permalink:"/docs/learn/xcm/journey-channels"}},r={},i=[{value:"LockAsset",id:"lockasset",level:2},{value:"UnlockAsset",id:"unlockasset",level:2},{value:"NoteUnlockable",id:"noteunlockable",level:2},{value:"RequestUnlock",id:"requestunlock",level:2},{value:"Example",id:"example",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3}];function h(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"locking",children:"Locking"})}),"\n",(0,t.jsxs)(n.p,{children:["Assets can be locked via XCM, meaning, the transfer or withdrawal of assets can be restricted via\nmessages. The XCM locking mechanism consists of four instructions: ",(0,t.jsx)(n.code,{children:"LockAsset"}),", ",(0,t.jsx)(n.code,{children:"UnlockAsset"}),",\n",(0,t.jsx)(n.code,{children:"NoteUnlockable"}),", and ",(0,t.jsx)(n.code,{children:"RequestUnlock"}),". Let's explore each instruction in detail:"]}),"\n",(0,t.jsx)(n.h2,{id:"lockasset",children:"LockAsset"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"LockAsset { asset: MultiAsset, unlocker: MultiLocation }\n"})}),"\n",(0,t.jsx)(n.p,{children:"The LockAsset instruction is used to lock locally held assets and prevent further transfers or\nwithdrawals. This instruction requires two parameters:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"asset"}),": The asset(s) to be locked."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"unlocker"}),": The MultiLocation that can unlock the asset(s). This value must match the origin of a\ncorresponding ",(0,t.jsx)(n.code,{children:"UnlockAsset"})," instruction to unlock the asset."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When the locking operation succeeds, a ",(0,t.jsx)(n.code,{children:"NoteUnlockable"})," instruction is sent to the unlocker. This\ninstruction serves as a notification that the asset is now unlockable."]}),"\n",(0,t.jsx)(n.h2,{id:"unlockasset",children:"UnlockAsset"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"UnlockAsset { asset: MultiAsset, target: MultiLocation }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"UnlockAsset"})," instruction removes the lock on a specific asset on the local chain, allowing it\nto be transferred if there are no other restrictions. The following parameters are required:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"asset"}),": The asset to be unlocked."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"target"}),": The owner of the asset on the local chain."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"noteunlockable",children:"NoteUnlockable"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"NoteUnlockable { asset: MultiAsset, owner: MultiLocation }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"NoteUnlockable"})," instruction indicates that an asset has been locked on the system which the\nmessage originated from.",(0,t.jsx)(n.br,{}),"\n","The locked assets can only be unlocked by receiving an ",(0,t.jsx)(n.code,{children:"UnlockAsset"})," instruction from this chain.\nThis instruction requires the following parameters:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"asset"}),": The asset(s) which are now unlockable from this origin."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"owner"}),": The owner of the asset on the chain in which it was locked. This may be a location\nspecific to the origin network. The owner can request this origin to unlock the assets using a\n",(0,t.jsx)(n.code,{children:"RequestUnlock"})," instruction. However, the owner is not able to unlock the assets themselves."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It is essential to trust the origin to have locked the corresponding asset before sending this\nmessage."}),"\n",(0,t.jsx)(n.h2,{id:"requestunlock",children:"RequestUnlock"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust,",metastring:"noplayground",children:"RequestUnlock { asset: MultiAsset, locker: MultiLocation }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RequestUnlock"})," instruction is used to send an ",(0,t.jsx)(n.code,{children:"UnlockAsset"})," instruction to the ",(0,t.jsx)(n.code,{children:"locker"})," for a\ngiven asset. The following parameters are required:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"asset"}),": The asset(s) to be unlocked."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"locker"}),": The location from which a previous ",(0,t.jsx)(n.code,{children:"NoteUnlockable"})," was sent, and where the\n",(0,t.jsx)(n.code,{children:"UnlockAsset"})," instruction should be sent."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(n.p,{children:["To get a better grasp on how these instructions work together, we give two examples in this section.\nThe examples use the xcm-executor with the pallet-xcm as the implementation for the ",(0,t.jsx)(n.code,{children:"AssetLocker"}),"\nconfig item. An important note of this implementation is that only one lock with ID ",(0,t.jsx)(n.code,{children:"py/xcmlk"})," is\nset per account. The pallet-xcm implementation keeps track of all the xcm-related locks that are\nplaced on an account and sets the most restricting one with the ",(0,t.jsx)(n.code,{children:"py/xcmlk"})," lock ID. This principle\nbecomes more clear in the second example."]}),"\n",(0,t.jsx)(n.h3,{id:"example-1",children:"Example 1"}),"\n",(0,t.jsxs)(n.p,{children:["Check out the full ",(0,t.jsx)(n.a,{href:"https://github.com/paritytech/xcm-docs/tree/main/examples",children:"example code"}),". The\nscenario of this example is as follows:"]}),"\n",(0,t.jsx)(n.p,{children:"Parachain A locks 5 Cents of relay chain native assets of its Sovereign account on the relay chain\nand assigns Parachain B as unlocker. Parachain A then asks Parachain B to unlock the funds partly.\nParachain B responds by sending an UnlockAssets instruction to the relay chain."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Example",src:s(92218).A+"",width:"641",height:"371"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["send ",(0,t.jsx)(n.code,{children:"LockAsset"})," instruction from ParaA to relay."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"ParaA::execute_with(|| {\n    let message = Xcm(vec![LockAsset {\n        asset: (Here, CENTS * 5).into(),\n        unlocker: (Parachain(2)).into(),\n    }]);\n    assert_ok!(ParachainPalletXcm::send_xcm(Here, Parent, message.clone()));\n});\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["Parachain B receives this ",(0,t.jsx)(n.code,{children:"NoteUnlockable"})," instruction from the relay chain."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"NoteUnlockable {\n    owner: (Parent, Parachain(1)).into(),\n    asset: (Parent, CENTS * 5).into()\n}\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["Parachain A sends ",(0,t.jsx)(n.code,{children:"RequestUnlock"})," instruction to Parachain B"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"ParaA::execute_with(|| {\n    let message = Xcm(vec![RequestUnlock {\n        asset: (Parent, 3 * CENTS).into(),\n        locker: Parent.into(),\n    }]);\n    assert_ok!(ParachainPalletXcm::send_xcm(Here, (Parent, Parachain(2)), message.clone()));\n});\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:["Parachain B sends an ",(0,t.jsx)(n.code,{children:"UnlockAsset"})," instruction to the relay chain. We check if the lock is\nupdated accordingly:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    relay_chain::Balances::locks(&parachain_sovereign_account_id(1)),\n    vec![BalanceLock { id: *b"py/xcmlk", amount: 2 * CENTS, reasons: Reasons::All }]\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-2",children:"Example 2"}),"\n",(0,t.jsxs)(n.p,{children:["Check out the full ",(0,t.jsx)(n.a,{href:"https://github.com/paritytech/xcm-docs/tree/main/examples",children:"example code"}),". The\nscenario of this example is as follows:"]}),"\n",(0,t.jsx)(n.p,{children:"Parachain A sets two locks on the relay chain with as unlockers Parachain B and Parachain C.\nParachain A then requests Parachain B to partly unlock."}),"\n",(0,t.jsx)(n.p,{children:"Note: The locks overlap. When there are two or more locks, the total assets that are locked is equal\nto the most restrictive lock (the lock that locks the most assets). When the most restrictive lock\nis unlocked, the total locked assets is than equal to the next most restrictive lock."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Example",src:s(22385).A+"",width:"821",height:"371"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Set locks on the relay chain. Unlockers: B, C; Locks registered in pallet-xcm: 10, 5. Lock set in\npallet-balances: 10."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust,",metastring:"noplayground",children:'ParaA::execute_with(|| {\n    let message = Xcm(vec![\n        LockAsset { asset: (Here, 10 * CENTS).into(), unlocker: (Parachain(2)).into() },\n        LockAsset { asset: (Here, 5 * CENTS).into(), unlocker: (Parachain(3)).into() },\n    ]);\n    assert_ok!(ParachainPalletXcm::send_xcm(Here, Parent, message.clone()));\n});\n\nRelay::execute_with(|| {\n    assert_eq!(\n        relay_chain::Balances::locks(&parachain_sovereign_account_id(1)),\n        vec![BalanceLock { id: *b"py/xcmlk", amount: 10 * CENTS, reasons: Reasons::All }]\n    );\n});\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["Parachain B and C receive the ",(0,t.jsx)(n.code,{children:"NoteUnlockable"})," instruction."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust,",metastring:"noplayground",children:"ParaB::execute_with(|| {\n    assert_eq!(\n        parachain::MsgQueue::received_dmp(),\n        vec![Xcm(vec![NoteUnlockable {\n            owner: (Parent, Parachain(1)).into(),\n            asset: (Parent, 10 * CENTS).into()\n        }])]\n    );\n});\n\nParaC::execute_with(|| {\n    assert_eq!(\n        parachain::MsgQueue::received_dmp(),\n        vec![Xcm(vec![NoteUnlockable {\n            owner: (Parent, Parachain(1)).into(),\n            asset: (Parent, 5 * CENTS).into()\n        }])]\n    );\n});\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["Parachain A sends a ",(0,t.jsx)(n.code,{children:"RequestUnlock"})," instruction to Parachain B for 8 CENTS."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust,",metastring:"noplayground",children:"ParaA::execute_with(|| {\n    let message = Xcm(vec![RequestUnlock {\n        asset: (Parent, 8 * CENTS).into(),\n        locker: Parent.into(),\n    }]);\n\n    assert_ok!(ParachainPalletXcm::send_xcm(Here, (Parent, Parachain(2)), message.clone()));\n});\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:["Parachain B Unlocks a part of the funds by sending an ",(0,t.jsx)(n.code,{children:"UnlockAsset"})," to the relay chain. we check\nthe lock in the balances-pallet. Unlockers: B, C; Funds registered in pallet-xcm: 2, 5. Lock set\nin pallet-balances: 5."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'Relay::execute_with(|| {\n    assert_eq!(\n        relay_chain::Balances::locks(&parachain_sovereign_account_id(1)),\n        vec![BalanceLock { id: *b"py/xcmlk", amount: 5 * CENTS, reasons: Reasons::All }]\n    );\n});\n'})})]})}function d(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},92218:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/Example1-61d1f7cdd7d0e964d4cde7e1b412b1b9.png"},22385:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/Example2-6a5a1beb78bc98d9546a7f2771d6f091.png"},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(96540);const c={},a=t.createContext(c);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);